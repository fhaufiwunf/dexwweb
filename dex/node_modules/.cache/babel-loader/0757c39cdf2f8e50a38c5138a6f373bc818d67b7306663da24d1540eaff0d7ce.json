{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExportVisitor_referencer, _ExportVisitor_exportNode;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst Visitor_1 = require(\"./Visitor\");\nclass ExportVisitor extends Visitor_1.Visitor {\n  constructor(node, referencer) {\n    super(referencer);\n    _ExportVisitor_referencer.set(this, void 0);\n    _ExportVisitor_exportNode.set(this, void 0);\n    __classPrivateFieldSet(this, _ExportVisitor_exportNode, node, \"f\");\n    __classPrivateFieldSet(this, _ExportVisitor_referencer, referencer, \"f\");\n  }\n  static visit(referencer, node) {\n    const exportReferencer = new ExportVisitor(node, referencer);\n    exportReferencer.visit(node);\n  }\n  Identifier(node) {\n    if (__classPrivateFieldGet(this, _ExportVisitor_exportNode, \"f\").exportKind === 'type') {\n      // export type { T };\n      // type exports can only reference types\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceType(node);\n    } else {\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceDualValueType(node);\n    }\n  }\n  ExportDefaultDeclaration(node) {\n    if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {\n      // export default A;\n      // this could be a type or a variable\n      this.visit(node.declaration);\n    } else {\n      // export const a = 1;\n      // export something();\n      // etc\n      // these not included in the scope of this visitor as they are all guaranteed to be values or declare variables\n    }\n  }\n  ExportNamedDeclaration(node) {\n    if (node.source) {\n      // export ... from 'foo';\n      // these are external identifiers so there shouldn't be references or defs\n      return;\n    }\n    if (!node.declaration) {\n      // export { x };\n      this.visitChildren(node);\n    } else {\n      // export const x = 1;\n      // this is not included in the scope of this visitor as it creates a variable\n    }\n  }\n  ExportSpecifier(node) {\n    if (node.exportKind === 'type') {\n      // export { type T };\n      // type exports can only reference types\n      //\n      // we can't let this fall through to the Identifier selector because the exportKind is on this node\n      // and we don't have access to the `.parent` during scope analysis\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceType(node.local);\n    } else {\n      this.visit(node.local);\n    }\n  }\n}\nexports.ExportVisitor = ExportVisitor;\n_ExportVisitor_referencer = new WeakMap(), _ExportVisitor_exportNode = new WeakMap();","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AACA;AAGA;AAOA,MAAMA,aAAc,SAAQC,iBAAO;EAIjCC,YAAYC,IAAgB,EAAEC,UAAsB;IAClD,KAAK,CAACA,UAAU,CAAC;IAJVC;IACAC;IAIPC,2BAAI,6BAAeJ,IAAI;IACvBI,2BAAI,6BAAeH,UAAU;EAC/B;EAEA,OAAOI,KAAKA,CAACJ,UAAsB,EAAED,IAAgB;IACnD,MAAMM,gBAAgB,GAAG,IAAIT,aAAa,CAACG,IAAI,EAAEC,UAAU,CAAC;IAC5DK,gBAAgB,CAACD,KAAK,CAACL,IAAI,CAAC;EAC9B;EAEUO,UAAUA,CAACP,IAAyB;IAC5C,IAAIQ,2BAAI,iCAAY,CAACC,UAAU,KAAK,MAAM,EAAE;MAC1C;MACA;MACAD,2BAAI,iCAAY,CAACE,YAAY,EAAE,CAACC,aAAa,CAACX,IAAI,CAAC;KACpD,MAAM;MACLQ,2BAAI,iCAAY,CAACE,YAAY,EAAE,CAACE,sBAAsB,CAACZ,IAAI,CAAC;;EAEhE;EAEUa,wBAAwBA,CAChCb,IAAuC;IAEvC,IAAIA,IAAI,CAACc,WAAW,CAACC,IAAI,KAAKC,sBAAc,CAACT,UAAU,EAAE;MACvD;MACA;MACA,IAAI,CAACF,KAAK,CAACL,IAAI,CAACc,WAAW,CAAC;KAC7B,MAAM;MACL;MACA;MACA;MACA;IAAA;EAEJ;EAEUG,sBAAsBA,CAC9BjB,IAAqC;IAErC,IAAIA,IAAI,CAACkB,MAAM,EAAE;MACf;MACA;MACA;;IAGF,IAAI,CAAClB,IAAI,CAACc,WAAW,EAAE;MACrB;MACA,IAAI,CAACK,aAAa,CAACnB,IAAI,CAAC;KACzB,MAAM;MACL;MACA;IAAA;EAEJ;EAEUoB,eAAeA,CAACpB,IAA8B;IACtD,IAAIA,IAAI,CAACS,UAAU,KAAK,MAAM,EAAE;MAC9B;MACA;MACA;MACA;MACA;MACAD,2BAAI,iCAAY,CAACE,YAAY,EAAE,CAACC,aAAa,CAACX,IAAI,CAACqB,KAAK,CAAC;KAC1D,MAAM;MACL,IAAI,CAAChB,KAAK,CAACL,IAAI,CAACqB,KAAK,CAAC;;EAE1B;;AAGOC","names":["ExportVisitor","Visitor_1","constructor","node","referencer","_ExportVisitor_referencer","_ExportVisitor_exportNode","__classPrivateFieldSet","visit","exportReferencer","Identifier","__classPrivateFieldGet","exportKind","currentScope","referenceType","referenceDualValueType","ExportDefaultDeclaration","declaration","type","types_1","ExportNamedDeclaration","source","visitChildren","ExportSpecifier","local","exports"],"sources":["../../src/referencer/ExportVisitor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}