{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBaseClassMemberOfClassElement = exports.getIteratorYieldResultFromIteratorResult = exports.getInstanceTypeOfClassLikeDeclaration = exports.getConstructorTypeOfClassLikeDeclaration = exports.getSymbolOfClassLikeDeclaration = exports.getPropertyNameFromType = exports.symbolHasReadonlyDeclaration = exports.isPropertyReadonlyInType = exports.getWellKnownSymbolPropertyOfType = exports.getPropertyOfType = exports.isBooleanLiteralType = exports.isFalsyType = exports.isThenableType = exports.someTypePart = exports.intersectionTypeParts = exports.unionTypeParts = exports.getCallSignaturesOfType = exports.isTypeAssignableToString = exports.isTypeAssignableToNumber = exports.isOptionalChainingUndefinedMarkerType = exports.removeOptionalChainingUndefinedMarkerType = exports.removeOptionalityFromType = exports.isEmptyObjectType = void 0;\nconst ts = require(\"typescript\");\nconst type_1 = require(\"../typeguard/type\");\nconst util_1 = require(\"./util\");\nconst node_1 = require(\"../typeguard/node\");\nfunction isEmptyObjectType(type) {\n  if (type_1.isObjectType(type) && type.objectFlags & ts.ObjectFlags.Anonymous && type.getProperties().length === 0 && type.getCallSignatures().length === 0 && type.getConstructSignatures().length === 0 && type.getStringIndexType() === undefined && type.getNumberIndexType() === undefined) {\n    const baseTypes = type.getBaseTypes();\n    return baseTypes === undefined || baseTypes.every(isEmptyObjectType);\n  }\n  return false;\n}\nexports.isEmptyObjectType = isEmptyObjectType;\nfunction removeOptionalityFromType(checker, type) {\n  if (!containsTypeWithFlag(type, ts.TypeFlags.Undefined)) return type;\n  const allowsNull = containsTypeWithFlag(type, ts.TypeFlags.Null);\n  type = checker.getNonNullableType(type);\n  return allowsNull ? checker.getNullableType(type, ts.TypeFlags.Null) : type;\n}\nexports.removeOptionalityFromType = removeOptionalityFromType;\nfunction containsTypeWithFlag(type, flag) {\n  for (const t of unionTypeParts(type)) if (util_1.isTypeFlagSet(t, flag)) return true;\n  return false;\n}\nfunction removeOptionalChainingUndefinedMarkerType(checker, type) {\n  if (!type_1.isUnionType(type)) return isOptionalChainingUndefinedMarkerType(checker, type) ? type.getNonNullableType() : type;\n  let flags = 0;\n  let containsUndefinedMarker = false;\n  for (const t of type.types) {\n    if (isOptionalChainingUndefinedMarkerType(checker, t)) {\n      containsUndefinedMarker = true;\n    } else {\n      flags |= t.flags;\n    }\n  }\n  return containsUndefinedMarker ? checker.getNullableType(type.getNonNullableType(), flags) : type;\n}\nexports.removeOptionalChainingUndefinedMarkerType = removeOptionalChainingUndefinedMarkerType;\nfunction isOptionalChainingUndefinedMarkerType(checker, t) {\n  return util_1.isTypeFlagSet(t, ts.TypeFlags.Undefined) && checker.getNullableType(t.getNonNullableType(), ts.TypeFlags.Undefined) !== t;\n}\nexports.isOptionalChainingUndefinedMarkerType = isOptionalChainingUndefinedMarkerType;\nfunction isTypeAssignableToNumber(checker, type) {\n  return isTypeAssignableTo(checker, type, ts.TypeFlags.NumberLike);\n}\nexports.isTypeAssignableToNumber = isTypeAssignableToNumber;\nfunction isTypeAssignableToString(checker, type) {\n  return isTypeAssignableTo(checker, type, ts.TypeFlags.StringLike);\n}\nexports.isTypeAssignableToString = isTypeAssignableToString;\nfunction isTypeAssignableTo(checker, type, flags) {\n  flags |= ts.TypeFlags.Any;\n  let typeParametersSeen;\n  return function check(t) {\n    if (type_1.isTypeParameter(t) && t.symbol !== undefined && t.symbol.declarations !== undefined) {\n      if (typeParametersSeen === undefined) {\n        typeParametersSeen = new Set([t]);\n      } else if (!typeParametersSeen.has(t)) {\n        typeParametersSeen.add(t);\n      } else {\n        return false;\n      }\n      const declaration = t.symbol.declarations[0];\n      if (declaration.constraint === undefined) return true; // TODO really?\n      return check(checker.getTypeFromTypeNode(declaration.constraint));\n    }\n    if (type_1.isUnionType(t)) return t.types.every(check);\n    if (type_1.isIntersectionType(t)) return t.types.some(check);\n    return util_1.isTypeFlagSet(t, flags);\n  }(type);\n}\nfunction getCallSignaturesOfType(type) {\n  if (type_1.isUnionType(type)) {\n    const signatures = [];\n    for (const t of type.types) signatures.push(...getCallSignaturesOfType(t));\n    return signatures;\n  }\n  if (type_1.isIntersectionType(type)) {\n    let signatures;\n    for (const t of type.types) {\n      const sig = getCallSignaturesOfType(t);\n      if (sig.length !== 0) {\n        if (signatures !== undefined) return []; // if more than one type of the intersection has call signatures, none of them is useful for inference\n        signatures = sig;\n      }\n    }\n    return signatures === undefined ? [] : signatures;\n  }\n  return type.getCallSignatures();\n}\nexports.getCallSignaturesOfType = getCallSignaturesOfType;\n/** Returns all types of a union type or an array containing `type` itself if it's no union type. */\nfunction unionTypeParts(type) {\n  return type_1.isUnionType(type) ? type.types : [type];\n}\nexports.unionTypeParts = unionTypeParts;\n/** Returns all types of a intersection type or an array containing `type` itself if it's no intersection type. */\nfunction intersectionTypeParts(type) {\n  return type_1.isIntersectionType(type) ? type.types : [type];\n}\nexports.intersectionTypeParts = intersectionTypeParts;\nfunction someTypePart(type, predicate, cb) {\n  return predicate(type) ? type.types.some(cb) : cb(type);\n}\nexports.someTypePart = someTypePart;\nfunction isThenableType(checker, node) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : checker.getTypeAtLocation(node);\n  for (const ty of unionTypeParts(checker.getApparentType(type))) {\n    const then = ty.getProperty('then');\n    if (then === undefined) continue;\n    const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n    for (const t of unionTypeParts(thenType)) for (const signature of t.getCallSignatures()) if (signature.parameters.length !== 0 && isCallback(checker, signature.parameters[0], node)) return true;\n  }\n  return false;\n}\nexports.isThenableType = isThenableType;\nfunction isCallback(checker, param, node) {\n  let type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n  if (param.valueDeclaration.dotDotDotToken) {\n    // unwrap array type of rest parameter\n    type = type.getNumberIndexType();\n    if (type === undefined) return false;\n  }\n  for (const t of unionTypeParts(type)) if (t.getCallSignatures().length !== 0) return true;\n  return false;\n}\n/** Determine if a type is definitely falsy. This function doesn't unwrap union types. */\nfunction isFalsyType(type) {\n  if (type.flags & (ts.TypeFlags.Undefined | ts.TypeFlags.Null | ts.TypeFlags.Void)) return true;\n  if (type_1.isLiteralType(type)) return !type.value;\n  return isBooleanLiteralType(type, false);\n}\nexports.isFalsyType = isFalsyType;\n/** Determines whether the given type is a boolean literal type and matches the given boolean literal (true or false). */\nfunction isBooleanLiteralType(type, literal) {\n  return util_1.isTypeFlagSet(type, ts.TypeFlags.BooleanLiteral) && type.intrinsicName === (literal ? 'true' : 'false');\n}\nexports.isBooleanLiteralType = isBooleanLiteralType;\nfunction getPropertyOfType(type, name) {\n  if (!name.startsWith('__')) return type.getProperty(name);\n  return type.getProperties().find(s => s.escapedName === name);\n}\nexports.getPropertyOfType = getPropertyOfType;\nfunction getWellKnownSymbolPropertyOfType(type, wellKnownSymbolName, checker) {\n  const prefix = '__@' + wellKnownSymbolName;\n  for (const prop of type.getProperties()) {\n    if (!prop.name.startsWith(prefix)) continue;\n    const globalSymbol = checker.getApparentType(checker.getTypeAtLocation(prop.valueDeclaration.name.expression)).symbol;\n    if (prop.escapedName === getPropertyNameOfWellKnownSymbol(checker, globalSymbol, wellKnownSymbolName)) return prop;\n  }\n  return;\n}\nexports.getWellKnownSymbolPropertyOfType = getWellKnownSymbolPropertyOfType;\nfunction getPropertyNameOfWellKnownSymbol(checker, symbolConstructor, symbolName) {\n  const knownSymbol = symbolConstructor && checker.getTypeOfSymbolAtLocation(symbolConstructor, symbolConstructor.valueDeclaration).getProperty(symbolName);\n  const knownSymbolType = knownSymbol && checker.getTypeOfSymbolAtLocation(knownSymbol, knownSymbol.valueDeclaration);\n  if (knownSymbolType && type_1.isUniqueESSymbolType(knownSymbolType)) return knownSymbolType.escapedName;\n  return '__@' + symbolName;\n}\n/** Determines if writing to a certain property of a given type is allowed. */\nfunction isPropertyReadonlyInType(type, name, checker) {\n  let seenProperty = false;\n  let seenReadonlySignature = false;\n  for (const t of unionTypeParts(type)) {\n    if (getPropertyOfType(t, name) === undefined) {\n      // property is not present in this part of the union -> check for readonly index signature\n      const index = (util_1.isNumericPropertyName(name) ? checker.getIndexInfoOfType(t, ts.IndexKind.Number) : undefined) || checker.getIndexInfoOfType(t, ts.IndexKind.String);\n      if (index !== undefined && index.isReadonly) {\n        if (seenProperty) return true;\n        seenReadonlySignature = true;\n      }\n    } else if (seenReadonlySignature || isReadonlyPropertyIntersection(t, name, checker)) {\n      return true;\n    } else {\n      seenProperty = true;\n    }\n  }\n  return false;\n}\nexports.isPropertyReadonlyInType = isPropertyReadonlyInType;\nfunction isReadonlyPropertyIntersection(type, name, checker) {\n  return someTypePart(type, type_1.isIntersectionType, t => {\n    const prop = getPropertyOfType(t, name);\n    if (prop === undefined) return false;\n    if (prop.flags & ts.SymbolFlags.Transient) {\n      if (/^(?:[1-9]\\d*|0)$/.test(name) && type_1.isTupleTypeReference(t)) return t.target.readonly;\n      switch (isReadonlyPropertyFromMappedType(t, name, checker)) {\n        case true:\n          return true;\n        case false:\n          return false;\n        default:\n        // `undefined` falls through\n      }\n    }\n    return (\n      // members of namespace import\n      util_1.isSymbolFlagSet(prop, ts.SymbolFlags.ValueModule) ||\n      // we unwrapped every mapped type, now we can check the actual declarations\n      symbolHasReadonlyDeclaration(prop, checker)\n    );\n  });\n}\nfunction isReadonlyPropertyFromMappedType(type, name, checker) {\n  if (!type_1.isObjectType(type) || !util_1.isObjectFlagSet(type, ts.ObjectFlags.Mapped)) return;\n  const declaration = type.symbol.declarations[0];\n  // well-known symbols are not affected by mapped types\n  if (declaration.readonlyToken !== undefined && !/^__@[^@]+$/.test(name)) return declaration.readonlyToken.kind !== ts.SyntaxKind.MinusToken;\n  return isPropertyReadonlyInType(type.modifiersType, name, checker);\n}\nfunction symbolHasReadonlyDeclaration(symbol, checker) {\n  return (symbol.flags & ts.SymbolFlags.Accessor) === ts.SymbolFlags.GetAccessor || symbol.declarations !== undefined && symbol.declarations.some(node => util_1.isModifierFlagSet(node, ts.ModifierFlags.Readonly) || node_1.isVariableDeclaration(node) && util_1.isNodeFlagSet(node.parent, ts.NodeFlags.Const) || node_1.isCallExpression(node) && util_1.isReadonlyAssignmentDeclaration(node, checker) || node_1.isEnumMember(node) || (node_1.isPropertyAssignment(node) || node_1.isShorthandPropertyAssignment(node)) && util_1.isInConstContext(node.parent));\n}\nexports.symbolHasReadonlyDeclaration = symbolHasReadonlyDeclaration;\n/** Returns the the literal name or unique symbol name from a given type. Doesn't unwrap union types. */\nfunction getPropertyNameFromType(type) {\n  // string or number literal. bigint is intentionally excluded\n  if (type.flags & (ts.TypeFlags.StringLiteral | ts.TypeFlags.NumberLiteral)) {\n    const value = String(type.value);\n    return {\n      displayName: value,\n      symbolName: ts.escapeLeadingUnderscores(value)\n    };\n  }\n  if (type_1.isUniqueESSymbolType(type)) return {\n    displayName: `[${type.symbol ? `${isKnownSymbol(type.symbol) ? 'Symbol.' : ''}${type.symbol.name}` : type.escapedName.replace(/^__@|@\\d+$/g, '')}]`,\n    symbolName: type.escapedName\n  };\n}\nexports.getPropertyNameFromType = getPropertyNameFromType;\nfunction isKnownSymbol(symbol) {\n  return util_1.isSymbolFlagSet(symbol, ts.SymbolFlags.Property) && symbol.valueDeclaration !== undefined && node_1.isInterfaceDeclaration(symbol.valueDeclaration.parent) && symbol.valueDeclaration.parent.name.text === 'SymbolConstructor' && isGlobalDeclaration(symbol.valueDeclaration.parent);\n}\nfunction isGlobalDeclaration(node) {\n  return util_1.isNodeFlagSet(node.parent, ts.NodeFlags.GlobalAugmentation) || node_1.isSourceFile(node.parent) && !ts.isExternalModule(node.parent);\n}\nfunction getSymbolOfClassLikeDeclaration(node, checker) {\n  var _a;\n  return checker.getSymbolAtLocation((_a = node.name) !== null && _a !== void 0 ? _a : util_1.getChildOfKind(node, ts.SyntaxKind.ClassKeyword));\n}\nexports.getSymbolOfClassLikeDeclaration = getSymbolOfClassLikeDeclaration;\nfunction getConstructorTypeOfClassLikeDeclaration(node, checker) {\n  return node.kind === ts.SyntaxKind.ClassExpression ? checker.getTypeAtLocation(node) : checker.getTypeOfSymbolAtLocation(getSymbolOfClassLikeDeclaration(node, checker), node);\n}\nexports.getConstructorTypeOfClassLikeDeclaration = getConstructorTypeOfClassLikeDeclaration;\nfunction getInstanceTypeOfClassLikeDeclaration(node, checker) {\n  return node.kind === ts.SyntaxKind.ClassDeclaration ? checker.getTypeAtLocation(node) : checker.getDeclaredTypeOfSymbol(getSymbolOfClassLikeDeclaration(node, checker));\n}\nexports.getInstanceTypeOfClassLikeDeclaration = getInstanceTypeOfClassLikeDeclaration;\nfunction getIteratorYieldResultFromIteratorResult(type, node, checker) {\n  return type_1.isUnionType(type) && type.types.find(t => {\n    const done = t.getProperty('done');\n    return done !== undefined && isBooleanLiteralType(removeOptionalityFromType(checker, checker.getTypeOfSymbolAtLocation(done, node)), false);\n  }) || type;\n}\nexports.getIteratorYieldResultFromIteratorResult = getIteratorYieldResultFromIteratorResult;\n/** Lookup the declaration of a class member in the super class. */\nfunction getBaseClassMemberOfClassElement(node, checker) {\n  if (!node_1.isClassLikeDeclaration(node.parent)) return;\n  const base = util_1.getBaseOfClassLikeExpression(node.parent);\n  if (base === undefined) return;\n  const name = util_1.getSingleLateBoundPropertyNameOfPropertyName(node.name, checker);\n  if (name === undefined) return;\n  const baseType = checker.getTypeAtLocation(util_1.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword) ? base.expression : base);\n  return getPropertyOfType(baseType, name.symbolName);\n}\nexports.getBaseClassMemberOfClassElement = getBaseClassMemberOfClassElement;","map":{"version":3,"mappings":"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","names":["isEmptyObjectType","type","type_1","objectFlags","ts","ObjectFlags","Anonymous","getProperties","length","getCallSignatures","getConstructSignatures","getStringIndexType","undefined","getNumberIndexType","baseTypes","getBaseTypes","every","exports","removeOptionalityFromType","checker","containsTypeWithFlag","TypeFlags","Undefined","allowsNull","Null","getNonNullableType","getNullableType","flag","t","unionTypeParts","util_1","removeOptionalChainingUndefinedMarkerType","isOptionalChainingUndefinedMarkerType","flags","containsUndefinedMarker","types","isTypeAssignableToNumber","isTypeAssignableTo","NumberLike","isTypeAssignableToString","StringLike","Any","typeParametersSeen","check","symbol","declarations","Set","has","add","declaration","constraint","getTypeFromTypeNode","some","getCallSignaturesOfType","signatures","push","sig","intersectionTypeParts","someTypePart","predicate","cb","isThenableType","node","getTypeAtLocation","ty","getApparentType","then","getProperty","thenType","getTypeOfSymbolAtLocation","signature","parameters","isCallback","param","valueDeclaration","dotDotDotToken","isFalsyType","Void","value","isBooleanLiteralType","literal","BooleanLiteral","intrinsicName","getPropertyOfType","name","startsWith","find","s","escapedName","getWellKnownSymbolPropertyOfType","wellKnownSymbolName","prefix","prop","globalSymbol","expression","getPropertyNameOfWellKnownSymbol","symbolConstructor","symbolName","knownSymbol","knownSymbolType","isPropertyReadonlyInType","seenProperty","seenReadonlySignature","index","getIndexInfoOfType","IndexKind","Number","String","isReadonly","isReadonlyPropertyIntersection","SymbolFlags","Transient","test","target","readonly","isReadonlyPropertyFromMappedType","ValueModule","symbolHasReadonlyDeclaration","Mapped","readonlyToken","kind","SyntaxKind","MinusToken","modifiersType","Accessor","GetAccessor","ModifierFlags","Readonly","node_1","parent","NodeFlags","Const","getPropertyNameFromType","StringLiteral","NumberLiteral","displayName","escapeLeadingUnderscores","isKnownSymbol","replace","Property","text","isGlobalDeclaration","GlobalAugmentation","isExternalModule","getSymbolOfClassLikeDeclaration","getSymbolAtLocation","ClassKeyword","getConstructorTypeOfClassLikeDeclaration","ClassExpression","getInstanceTypeOfClassLikeDeclaration","ClassDeclaration","getDeclaredTypeOfSymbol","getIteratorYieldResultFromIteratorResult","done","getBaseClassMemberOfClassElement","base","baseType","modifiers","StaticKeyword"],"sources":["type.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}