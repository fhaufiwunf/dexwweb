{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ClassVisitor_classNode, _ClassVisitor_referencer, _ClassVisitor_emitDecoratorMetadata;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst definition_1 = require(\"../definition\");\nconst TypeVisitor_1 = require(\"./TypeVisitor\");\nconst Visitor_1 = require(\"./Visitor\");\nclass ClassVisitor extends Visitor_1.Visitor {\n  constructor(referencer, node, emitDecoratorMetadata) {\n    super(referencer);\n    _ClassVisitor_classNode.set(this, void 0);\n    _ClassVisitor_referencer.set(this, void 0);\n    _ClassVisitor_emitDecoratorMetadata.set(this, void 0);\n    __classPrivateFieldSet(this, _ClassVisitor_referencer, referencer, \"f\");\n    __classPrivateFieldSet(this, _ClassVisitor_classNode, node, \"f\");\n    __classPrivateFieldSet(this, _ClassVisitor_emitDecoratorMetadata, emitDecoratorMetadata, \"f\");\n  }\n  static visit(referencer, node, emitDecoratorMetadata) {\n    const classVisitor = new ClassVisitor(referencer, node, emitDecoratorMetadata);\n    classVisitor.visitClass(node);\n  }\n  visit(node) {\n    // make sure we only handle the nodes we are designed to handle\n    if (node && node.type in this) {\n      super.visit(node);\n    } else {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node);\n    }\n  }\n  ///////////////////\n  // Visit helpers //\n  ///////////////////\n  visitClass(node) {\n    var _a, _b;\n    if (node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n    }\n    (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassScope(node);\n    if (node.id) {\n      // define the class name again inside the new scope\n      // references to the class should not resolve directly to the parent class\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n    }\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.superClass);\n    // visit the type param declarations\n    this.visitType(node.typeParameters);\n    // then the usages\n    this.visitType(node.superTypeParameters);\n    (_b = node.implements) === null || _b === void 0 ? void 0 : _b.forEach(imp => this.visitType(imp));\n    this.visit(node.body);\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n  visitPropertyDefinition(node) {\n    this.visitPropertyBase(node);\n    /**\n     * class A {\n     *   @meta     // <--- check this\n     *   foo: Type;\n     * }\n     */\n    this.visitMetadataType(node.typeAnnotation, !!node.decorators);\n  }\n  visitFunctionParameterTypeAnnotation(node, withDecorators) {\n    if ('typeAnnotation' in node) {\n      this.visitMetadataType(node.typeAnnotation, withDecorators);\n    } else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {\n      this.visitMetadataType(node.left.typeAnnotation, withDecorators);\n    } else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {\n      this.visitFunctionParameterTypeAnnotation(node.parameter, withDecorators);\n    }\n  }\n  visitMethodFunction(node, methodNode) {\n    var _a, _b;\n    if (node.id) {\n      // FunctionExpression with name creates its special scope;\n      // FunctionExpressionNameScope.\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestFunctionExpressionNameScope(node);\n    }\n    // Consider this function is in the MethodDefinition.\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestFunctionScope(node, true);\n    /**\n     * class A {\n     *   @meta     // <--- check this\n     *   foo(a: Type) {}\n     *\n     *   @meta     // <--- check this\n     *   foo(): Type {}\n     * }\n     */\n    let withMethodDecorators = !!methodNode.decorators;\n    /**\n     * class A {\n     *   foo(\n     *     @meta    // <--- check this\n     *     a: Type\n     *   ) {}\n     *\n     *   set foo(\n     *     @meta    // <--- EXCEPT this. TS do nothing for this\n     *     a: Type\n     *   ) {}\n     * }\n     */\n    withMethodDecorators = withMethodDecorators || methodNode.kind !== 'set' && node.params.some(param => param.decorators);\n    if (!withMethodDecorators && methodNode.kind === 'set') {\n      const keyName = getLiteralMethodKeyName(methodNode);\n      /**\n       * class A {\n       *   @meta      // <--- check this\n       *   get a() {}\n       *   set ['a'](v: Type) {}\n       * }\n       */\n      if (keyName != null && ((_a = __classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").body.body.find(node => node !== methodNode && node.type === types_1.AST_NODE_TYPES.MethodDefinition &&\n      // Node must both be static or not\n      node.static === methodNode.static && getLiteralMethodKeyName(node) === keyName)) === null || _a === void 0 ? void 0 : _a.decorators)) {\n        withMethodDecorators = true;\n      }\n    }\n    /**\n     * @meta      // <--- check this\n     * class A {\n     *   constructor(a: Type) {}\n     * }\n     */\n    if (!withMethodDecorators && methodNode.kind === 'constructor' && __classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").decorators) {\n      withMethodDecorators = true;\n    }\n    // Process parameter declarations.\n    for (const param of node.params) {\n      this.visitPattern(param, (pattern, info) => {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").referencingDefaultValue(pattern, info.assignments, null, true);\n      }, {\n        processRightHandNodes: true\n      });\n      this.visitFunctionParameterTypeAnnotation(param, withMethodDecorators);\n      (_b = param.decorators) === null || _b === void 0 ? void 0 : _b.forEach(d => this.visit(d));\n    }\n    this.visitMetadataType(node.returnType, withMethodDecorators);\n    this.visitType(node.typeParameters);\n    // In TypeScript there are a number of function-like constructs which have no body,\n    // so check it exists before traversing\n    if (node.body) {\n      // Skip BlockStatement to prevent creating BlockStatement scope.\n      if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visitChildren(node.body);\n      } else {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.body);\n      }\n    }\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n  visitPropertyBase(node) {\n    var _a;\n    if (node.computed) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.key);\n    }\n    if (node.value) {\n      if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassFieldInitializerScope(node.value);\n      }\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.value);\n      if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node.value);\n      }\n    }\n    if ('decorators' in node) {\n      (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    }\n  }\n  visitMethod(node) {\n    var _a;\n    if (node.computed) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.key);\n    }\n    if (node.value.type === types_1.AST_NODE_TYPES.FunctionExpression) {\n      this.visitMethodFunction(node.value, node);\n    } else {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.value);\n    }\n    if ('decorators' in node) {\n      (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    }\n  }\n  visitType(node) {\n    if (!node) {\n      return;\n    }\n    TypeVisitor_1.TypeVisitor.visit(__classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\"), node);\n  }\n  visitMetadataType(node, withDecorators) {\n    if (!node) {\n      return;\n    }\n    // emit decorators metadata only work for TSTypeReference in ClassDeclaration\n    if (__classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").type === types_1.AST_NODE_TYPES.ClassDeclaration && !__classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").declare && node.typeAnnotation.type === types_1.AST_NODE_TYPES.TSTypeReference && __classPrivateFieldGet(this, _ClassVisitor_emitDecoratorMetadata, \"f\")) {\n      let entityName;\n      if (node.typeAnnotation.typeName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n        let iter = node.typeAnnotation.typeName;\n        while (iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n          iter = iter.left;\n        }\n        entityName = iter.left;\n      } else {\n        entityName = node.typeAnnotation.typeName;\n      }\n      if (withDecorators) {\n        if (entityName.type === types_1.AST_NODE_TYPES.Identifier) {\n          __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().referenceDualValueType(entityName);\n        }\n        if (node.typeAnnotation.typeParameters) {\n          this.visitType(node.typeAnnotation.typeParameters);\n        }\n        // everything is handled now\n        return;\n      }\n    }\n    this.visitType(node);\n  }\n  /////////////////////\n  // Visit selectors //\n  /////////////////////\n  AccessorProperty(node) {\n    this.visitPropertyDefinition(node);\n  }\n  ClassBody(node) {\n    // this is here on purpose so that this visitor explicitly declares visitors\n    // for all nodes it cares about (see the instance visit method above)\n    this.visitChildren(node);\n  }\n  PropertyDefinition(node) {\n    this.visitPropertyDefinition(node);\n  }\n  MethodDefinition(node) {\n    this.visitMethod(node);\n  }\n  TSAbstractAccessorProperty(node) {\n    this.visitPropertyDefinition(node);\n  }\n  TSAbstractPropertyDefinition(node) {\n    this.visitPropertyDefinition(node);\n  }\n  TSAbstractMethodDefinition(node) {\n    this.visitPropertyBase(node);\n  }\n  Identifier(node) {\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node);\n  }\n  PrivateIdentifier() {\n    // intentionally skip\n  }\n  StaticBlock(node) {\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassStaticBlockScope(node);\n    node.body.forEach(b => this.visit(b));\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n}\nexports.ClassVisitor = ClassVisitor;\n_ClassVisitor_classNode = new WeakMap(), _ClassVisitor_referencer = new WeakMap(), _ClassVisitor_emitDecoratorMetadata = new WeakMap();\n/**\n * Only if key is one of [identifier, string, number], ts will combine metadata of accessors .\n * class A {\n *   get a() {}\n *   set ['a'](v: Type) {}\n *\n *   get [1]() {}\n *   set [1](v: Type) {}\n *\n *   // Following won't be combined\n *   get [key]() {}\n *   set [key](v: Type) {}\n *\n *   get [true]() {}\n *   set [true](v: Type) {}\n *\n *   get ['a'+'b']() {}\n *   set ['a'+'b']() {}\n * }\n */\nfunction getLiteralMethodKeyName(node) {\n  if (node.computed && node.key.type === types_1.AST_NODE_TYPES.Literal) {\n    if (typeof node.key.value === 'string' || typeof node.key.value === 'number') {\n      return node.key.value;\n    }\n  } else if (!node.computed && node.key.type === types_1.AST_NODE_TYPES.Identifier) {\n    return node.key.name;\n  }\n  return null;\n}","map":{"version":3,"mappings":"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","names":["ClassVisitor","Visitor_1","constructor","referencer","node","emitDecoratorMetadata","_ClassVisitor_classNode","_ClassVisitor_referencer","_ClassVisitor_emitDecoratorMetadata","__classPrivateFieldSet","visit","classVisitor","visitClass","type","__classPrivateFieldGet","types_1","ClassDeclaration","id","currentScope","defineIdentifier","definition_1","decorators","forEach","d","scopeManager","nestClassScope","superClass","visitType","typeParameters","superTypeParameters","implements","imp","body","close","visitPropertyDefinition","visitPropertyBase","visitMetadataType","typeAnnotation","visitFunctionParameterTypeAnnotation","withDecorators","AssignmentPattern","left","TSParameterProperty","parameter","visitMethodFunction","methodNode","nestFunctionExpressionNameScope","nestFunctionScope","withMethodDecorators","kind","params","some","param","keyName","getLiteralMethodKeyName","find","MethodDefinition","static","visitPattern","pattern","info","rest","referencingDefaultValue","assignments","processRightHandNodes","returnType","BlockStatement","visitChildren","computed","key","value","PropertyDefinition","AccessorProperty","nestClassFieldInitializerScope","visitMethod","FunctionExpression","TypeVisitor_1","declare","TSTypeReference","entityName","typeName","TSQualifiedName","iter","Identifier","referenceDualValueType","ClassBody","TSAbstractAccessorProperty","TSAbstractPropertyDefinition","TSAbstractMethodDefinition","PrivateIdentifier","StaticBlock","nestClassStaticBlockScope","b","exports","Literal","name"],"sources":["../../src/referencer/ClassVisitor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}