{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidIdentifier = exports.getLineBreakStyle = exports.getLineRanges = exports.forEachComment = exports.forEachTokenWithTrivia = exports.forEachToken = exports.isFunctionWithBody = exports.hasOwnThisReference = exports.isBlockScopeBoundary = exports.isFunctionScopeBoundary = exports.isTypeScopeBoundary = exports.isScopeBoundary = exports.ScopeBoundarySelector = exports.ScopeBoundary = exports.isInSingleStatementContext = exports.isBlockScopedDeclarationStatement = exports.isBlockScopedVariableDeclaration = exports.isBlockScopedVariableDeclarationList = exports.getVariableDeclarationKind = exports.VariableDeclarationKind = exports.forEachDeclaredVariable = exports.forEachDestructuringIdentifier = exports.getPropertyName = exports.getWrappedNodeAtPosition = exports.getAstNodeAtPosition = exports.commentText = exports.isPositionInComment = exports.getCommentAtPosition = exports.getTokenAtPosition = exports.getNextToken = exports.getPreviousToken = exports.getNextStatement = exports.getPreviousStatement = exports.isModifierFlagSet = exports.isObjectFlagSet = exports.isSymbolFlagSet = exports.isTypeFlagSet = exports.isNodeFlagSet = exports.hasAccessModifier = exports.isParameterProperty = exports.hasModifier = exports.getModifier = exports.isThisParameter = exports.isKeywordKind = exports.isJsDocKind = exports.isTypeNodeKind = exports.isAssignmentKind = exports.isNodeKind = exports.isTokenKind = exports.getChildOfKind = void 0;\nexports.getBaseOfClassLikeExpression = exports.hasExhaustiveCaseClauses = exports.formatPseudoBigInt = exports.unwrapParentheses = exports.getSingleLateBoundPropertyNameOfPropertyName = exports.getLateBoundPropertyNamesOfPropertyName = exports.getLateBoundPropertyNames = exports.getPropertyNameOfWellKnownSymbol = exports.isWellKnownSymbolLiterally = exports.isBindableObjectDefinePropertyCall = exports.isReadonlyAssignmentDeclaration = exports.isInConstContext = exports.isConstAssertion = exports.getTsCheckDirective = exports.getCheckJsDirective = exports.isAmbientModule = exports.isCompilerOptionEnabled = exports.isStrictCompilerOptionEnabled = exports.getIIFE = exports.isAmbientModuleBlock = exports.isStatementInAmbientContext = exports.findImportLikeNodes = exports.findImports = exports.ImportKind = exports.parseJsDocOfNode = exports.getJsDoc = exports.canHaveJsDoc = exports.isReassignmentTarget = exports.getAccessKind = exports.AccessKind = exports.isExpressionValueUsed = exports.getDeclarationOfBindingElement = exports.hasSideEffects = exports.SideEffectOptions = exports.isSameLine = exports.isNumericPropertyName = exports.isValidJsxIdentifier = exports.isValidNumericLiteral = exports.isValidPropertyName = exports.isValidPropertyAccess = void 0;\nconst ts = require(\"typescript\");\nconst node_1 = require(\"../typeguard/node\");\nconst _3_2_1 = require(\"../typeguard/3.2\");\nconst type_1 = require(\"./type\");\nfunction getChildOfKind(node, kind, sourceFile) {\n  for (const child of node.getChildren(sourceFile)) if (child.kind === kind) return child;\n}\nexports.getChildOfKind = getChildOfKind;\nfunction isTokenKind(kind) {\n  return kind >= ts.SyntaxKind.FirstToken && kind <= ts.SyntaxKind.LastToken;\n}\nexports.isTokenKind = isTokenKind;\nfunction isNodeKind(kind) {\n  return kind >= ts.SyntaxKind.FirstNode;\n}\nexports.isNodeKind = isNodeKind;\nfunction isAssignmentKind(kind) {\n  return kind >= ts.SyntaxKind.FirstAssignment && kind <= ts.SyntaxKind.LastAssignment;\n}\nexports.isAssignmentKind = isAssignmentKind;\nfunction isTypeNodeKind(kind) {\n  return kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode;\n}\nexports.isTypeNodeKind = isTypeNodeKind;\nfunction isJsDocKind(kind) {\n  return kind >= ts.SyntaxKind.FirstJSDocNode && kind <= ts.SyntaxKind.LastJSDocNode;\n}\nexports.isJsDocKind = isJsDocKind;\nfunction isKeywordKind(kind) {\n  return kind >= ts.SyntaxKind.FirstKeyword && kind <= ts.SyntaxKind.LastKeyword;\n}\nexports.isKeywordKind = isKeywordKind;\nfunction isThisParameter(parameter) {\n  return parameter.name.kind === ts.SyntaxKind.Identifier && parameter.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword;\n}\nexports.isThisParameter = isThisParameter;\nfunction getModifier(node, kind) {\n  if (node.modifiers !== undefined) for (const modifier of node.modifiers) if (modifier.kind === kind) return modifier;\n}\nexports.getModifier = getModifier;\nfunction hasModifier(modifiers) {\n  if (modifiers === undefined) return false;\n  for (var _len = arguments.length, kinds = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    kinds[_key - 1] = arguments[_key];\n  }\n  for (const modifier of modifiers) if (kinds.includes(modifier.kind)) return true;\n  return false;\n}\nexports.hasModifier = hasModifier;\nfunction isParameterProperty(node) {\n  return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword, ts.SyntaxKind.ReadonlyKeyword);\n}\nexports.isParameterProperty = isParameterProperty;\nfunction hasAccessModifier(node) {\n  return isModifierFlagSet(node, ts.ModifierFlags.AccessibilityModifier);\n}\nexports.hasAccessModifier = hasAccessModifier;\nfunction isFlagSet(obj, flag) {\n  return (obj.flags & flag) !== 0;\n}\nexports.isNodeFlagSet = isFlagSet;\nexports.isTypeFlagSet = isFlagSet;\nexports.isSymbolFlagSet = isFlagSet;\nfunction isObjectFlagSet(objectType, flag) {\n  return (objectType.objectFlags & flag) !== 0;\n}\nexports.isObjectFlagSet = isObjectFlagSet;\nfunction isModifierFlagSet(node, flag) {\n  return (ts.getCombinedModifierFlags(node) & flag) !== 0;\n}\nexports.isModifierFlagSet = isModifierFlagSet;\nfunction getPreviousStatement(statement) {\n  const parent = statement.parent;\n  if (node_1.isBlockLike(parent)) {\n    const index = parent.statements.indexOf(statement);\n    if (index > 0) return parent.statements[index - 1];\n  }\n}\nexports.getPreviousStatement = getPreviousStatement;\nfunction getNextStatement(statement) {\n  const parent = statement.parent;\n  if (node_1.isBlockLike(parent)) {\n    const index = parent.statements.indexOf(statement);\n    if (index < parent.statements.length) return parent.statements[index + 1];\n  }\n}\nexports.getNextStatement = getNextStatement;\n/** Returns the token before the start of `node` or `undefined` if there is none. */\nfunction getPreviousToken(node, sourceFile) {\n  const {\n    pos\n  } = node;\n  if (pos === 0) return;\n  do node = node.parent; while (node.pos === pos);\n  return getTokenAtPositionWorker(node, pos - 1, sourceFile !== null && sourceFile !== void 0 ? sourceFile : node.getSourceFile(), false);\n}\nexports.getPreviousToken = getPreviousToken;\n/** Returns the next token that begins after the end of `node`. Returns `undefined` for SourceFile and EndOfFileToken */\nfunction getNextToken(node, sourceFile) {\n  if (node.kind === ts.SyntaxKind.SourceFile || node.kind === ts.SyntaxKind.EndOfFileToken) return;\n  const end = node.end;\n  node = node.parent;\n  while (node.end === end) {\n    if (node.parent === undefined) return node.endOfFileToken;\n    node = node.parent;\n  }\n  return getTokenAtPositionWorker(node, end, sourceFile !== null && sourceFile !== void 0 ? sourceFile : node.getSourceFile(), false);\n}\nexports.getNextToken = getNextToken;\n/** Returns the token at or following the specified position or undefined if none is found inside `parent`. */\nfunction getTokenAtPosition(parent, pos, sourceFile, allowJsDoc) {\n  if (pos < parent.pos || pos >= parent.end) return;\n  if (isTokenKind(parent.kind)) return parent;\n  return getTokenAtPositionWorker(parent, pos, sourceFile !== null && sourceFile !== void 0 ? sourceFile : parent.getSourceFile(), allowJsDoc === true);\n}\nexports.getTokenAtPosition = getTokenAtPosition;\nfunction getTokenAtPositionWorker(node, pos, sourceFile, allowJsDoc) {\n  if (!allowJsDoc) {\n    // if we are not interested in JSDoc, we can skip to the deepest AST node at the given position\n    node = getAstNodeAtPosition(node, pos);\n    if (isTokenKind(node.kind)) return node;\n  }\n  outer: while (true) {\n    for (const child of node.getChildren(sourceFile)) {\n      if (child.end > pos && (allowJsDoc || child.kind !== ts.SyntaxKind.JSDocComment)) {\n        if (isTokenKind(child.kind)) return child;\n        // next token is nested in another node\n        node = child;\n        continue outer;\n      }\n    }\n    return;\n  }\n}\n/**\r\n * Return the comment at the specified position.\r\n * You can pass an optional `parent` to avoid some work finding the corresponding token starting at `sourceFile`.\r\n * If the `parent` parameter is passed, `pos` must be between `parent.pos` and `parent.end`.\r\n*/\nfunction getCommentAtPosition(sourceFile, pos) {\n  let parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sourceFile;\n  const token = getTokenAtPosition(parent, pos, sourceFile);\n  if (token === undefined || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || '').length) return;\n  const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || '').length : token.pos;\n  return startPos !== 0 && ts.forEachTrailingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos);\n}\nexports.getCommentAtPosition = getCommentAtPosition;\nfunction commentAtPositionCallback(pos, end, kind, _nl, at) {\n  return at >= pos && at < end ? {\n    pos,\n    end,\n    kind\n  } : undefined;\n}\n/**\r\n * Returns whether the specified position is inside a comment.\r\n * You can pass an optional `parent` to avoid some work finding the corresponding token starting at `sourceFile`.\r\n * If the `parent` parameter is passed, `pos` must be between `parent.pos` and `parent.end`.\r\n */\nfunction isPositionInComment(sourceFile, pos, parent) {\n  return getCommentAtPosition(sourceFile, pos, parent) !== undefined;\n}\nexports.isPositionInComment = isPositionInComment;\nfunction commentText(sourceText, comment) {\n  return sourceText.substring(comment.pos + 2, comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? comment.end : comment.end - 2);\n}\nexports.commentText = commentText;\n/** Returns the deepest AST Node at `pos`. Returns undefined if `pos` is outside of the range of `node` */\nfunction getAstNodeAtPosition(node, pos) {\n  if (node.pos > pos || node.end <= pos) return;\n  while (isNodeKind(node.kind)) {\n    const nested = ts.forEachChild(node, child => child.pos <= pos && child.end > pos ? child : undefined);\n    if (nested === undefined) break;\n    node = nested;\n  }\n  return node;\n}\nexports.getAstNodeAtPosition = getAstNodeAtPosition;\n/**\r\n * Returns the NodeWrap of deepest AST node that contains `pos` between its `pos` and `end`.\r\n * Only returns undefined if pos is outside of `wrap`\r\n */\nfunction getWrappedNodeAtPosition(wrap, pos) {\n  if (wrap.node.pos > pos || wrap.node.end <= pos) return;\n  outer: while (true) {\n    for (const child of wrap.children) {\n      if (child.node.pos > pos) return wrap;\n      if (child.node.end > pos) {\n        wrap = child;\n        continue outer;\n      }\n    }\n    return wrap;\n  }\n}\nexports.getWrappedNodeAtPosition = getWrappedNodeAtPosition;\nfunction getPropertyName(propertyName) {\n  if (propertyName.kind === ts.SyntaxKind.ComputedPropertyName) {\n    const expression = unwrapParentheses(propertyName.expression);\n    if (node_1.isPrefixUnaryExpression(expression)) {\n      let negate = false;\n      switch (expression.operator) {\n        case ts.SyntaxKind.MinusToken:\n          negate = true;\n        // falls through\n        case ts.SyntaxKind.PlusToken:\n          return node_1.isNumericLiteral(expression.operand) ? `${negate ? '-' : ''}${expression.operand.text}` : _3_2_1.isBigIntLiteral(expression.operand) ? `${negate ? '-' : ''}${expression.operand.text.slice(0, -1)}` : undefined;\n        default:\n          return;\n      }\n    }\n    if (_3_2_1.isBigIntLiteral(expression))\n      // handle BigInt, even though TypeScript doesn't allow BigInt as computed property name\n      return expression.text.slice(0, -1);\n    if (node_1.isNumericOrStringLikeLiteral(expression)) return expression.text;\n    return;\n  }\n  return propertyName.kind === ts.SyntaxKind.PrivateIdentifier ? undefined : propertyName.text;\n}\nexports.getPropertyName = getPropertyName;\nfunction forEachDestructuringIdentifier(pattern, fn) {\n  for (const element of pattern.elements) {\n    if (element.kind !== ts.SyntaxKind.BindingElement) continue;\n    let result;\n    if (element.name.kind === ts.SyntaxKind.Identifier) {\n      result = fn(element);\n    } else {\n      result = forEachDestructuringIdentifier(element.name, fn);\n    }\n    if (result) return result;\n  }\n}\nexports.forEachDestructuringIdentifier = forEachDestructuringIdentifier;\nfunction forEachDeclaredVariable(declarationList, cb) {\n  for (const declaration of declarationList.declarations) {\n    let result;\n    if (declaration.name.kind === ts.SyntaxKind.Identifier) {\n      result = cb(declaration);\n    } else {\n      result = forEachDestructuringIdentifier(declaration.name, cb);\n    }\n    if (result) return result;\n  }\n}\nexports.forEachDeclaredVariable = forEachDeclaredVariable;\nvar VariableDeclarationKind;\n(function (VariableDeclarationKind) {\n  VariableDeclarationKind[VariableDeclarationKind[\"Var\"] = 0] = \"Var\";\n  VariableDeclarationKind[VariableDeclarationKind[\"Let\"] = 1] = \"Let\";\n  VariableDeclarationKind[VariableDeclarationKind[\"Const\"] = 2] = \"Const\";\n})(VariableDeclarationKind = exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));\nfunction getVariableDeclarationKind(declarationList) {\n  if (declarationList.flags & ts.NodeFlags.Let) return 1 /* Let */;\n  if (declarationList.flags & ts.NodeFlags.Const) return 2 /* Const */;\n  return 0 /* Var */;\n}\nexports.getVariableDeclarationKind = getVariableDeclarationKind;\nfunction isBlockScopedVariableDeclarationList(declarationList) {\n  return (declarationList.flags & ts.NodeFlags.BlockScoped) !== 0;\n}\nexports.isBlockScopedVariableDeclarationList = isBlockScopedVariableDeclarationList;\nfunction isBlockScopedVariableDeclaration(declaration) {\n  const parent = declaration.parent;\n  return parent.kind === ts.SyntaxKind.CatchClause || isBlockScopedVariableDeclarationList(parent);\n}\nexports.isBlockScopedVariableDeclaration = isBlockScopedVariableDeclaration;\nfunction isBlockScopedDeclarationStatement(statement) {\n  switch (statement.kind) {\n    case ts.SyntaxKind.VariableStatement:\n      return isBlockScopedVariableDeclarationList(statement.declarationList);\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n      return true;\n    default:\n      return false;\n  }\n}\nexports.isBlockScopedDeclarationStatement = isBlockScopedDeclarationStatement;\nfunction isInSingleStatementContext(statement) {\n  switch (statement.parent.kind) {\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.ForInStatement:\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.WhileStatement:\n    case ts.SyntaxKind.DoStatement:\n    case ts.SyntaxKind.IfStatement:\n    case ts.SyntaxKind.WithStatement:\n    case ts.SyntaxKind.LabeledStatement:\n      return true;\n    default:\n      return false;\n  }\n}\nexports.isInSingleStatementContext = isInSingleStatementContext;\nvar ScopeBoundary;\n(function (ScopeBoundary) {\n  ScopeBoundary[ScopeBoundary[\"None\"] = 0] = \"None\";\n  ScopeBoundary[ScopeBoundary[\"Function\"] = 1] = \"Function\";\n  ScopeBoundary[ScopeBoundary[\"Block\"] = 2] = \"Block\";\n  ScopeBoundary[ScopeBoundary[\"Type\"] = 4] = \"Type\";\n  ScopeBoundary[ScopeBoundary[\"ConditionalType\"] = 8] = \"ConditionalType\";\n})(ScopeBoundary = exports.ScopeBoundary || (exports.ScopeBoundary = {}));\nvar ScopeBoundarySelector;\n(function (ScopeBoundarySelector) {\n  ScopeBoundarySelector[ScopeBoundarySelector[\"Function\"] = 1] = \"Function\";\n  ScopeBoundarySelector[ScopeBoundarySelector[\"Block\"] = 3] = \"Block\";\n  ScopeBoundarySelector[ScopeBoundarySelector[\"Type\"] = 7] = \"Type\";\n  ScopeBoundarySelector[ScopeBoundarySelector[\"InferType\"] = 8] = \"InferType\";\n})(ScopeBoundarySelector = exports.ScopeBoundarySelector || (exports.ScopeBoundarySelector = {}));\nfunction isScopeBoundary(node) {\n  return isFunctionScopeBoundary(node) || isBlockScopeBoundary(node) || isTypeScopeBoundary(node);\n}\nexports.isScopeBoundary = isScopeBoundary;\nfunction isTypeScopeBoundary(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n    case ts.SyntaxKind.MappedType:\n      return 4 /* Type */;\n    case ts.SyntaxKind.ConditionalType:\n      return 8 /* ConditionalType */;\n    default:\n      return 0 /* None */;\n  }\n}\nexports.isTypeScopeBoundary = isTypeScopeBoundary;\nfunction isFunctionScopeBoundary(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.Constructor:\n    case ts.SyntaxKind.ModuleDeclaration:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.MethodSignature:\n    case ts.SyntaxKind.CallSignature:\n    case ts.SyntaxKind.ConstructSignature:\n    case ts.SyntaxKind.ConstructorType:\n    case ts.SyntaxKind.FunctionType:\n      return 1 /* Function */;\n    case ts.SyntaxKind.SourceFile:\n      // if SourceFile is no module, it contributes to the global scope and is therefore no scope boundary\n      return ts.isExternalModule(node) ? 1 /* Function */ : 0 /* None */;\n    default:\n      return 0 /* None */;\n  }\n}\nexports.isFunctionScopeBoundary = isFunctionScopeBoundary;\nfunction isBlockScopeBoundary(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.Block:\n      const parent = node.parent;\n      return parent.kind !== ts.SyntaxKind.CatchClause && (\n      // blocks inside SourceFile are block scope boundaries\n      parent.kind === ts.SyntaxKind.SourceFile ||\n      // blocks that are direct children of a function scope boundary are no scope boundary\n      // for example the FunctionBlock is part of the function scope of the containing function\n      !isFunctionScopeBoundary(parent)) ? 2 /* Block */ : 0 /* None */;\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.ForInStatement:\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.CaseBlock:\n    case ts.SyntaxKind.CatchClause:\n    case ts.SyntaxKind.WithStatement:\n      return 2 /* Block */;\n    default:\n      return 0 /* None */;\n  }\n}\nexports.isBlockScopeBoundary = isBlockScopeBoundary;\n/** Returns true for scope boundaries that have their own `this` reference instead of inheriting it from the containing scope */\nfunction hasOwnThisReference(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.FunctionExpression:\n      return true;\n    case ts.SyntaxKind.FunctionDeclaration:\n      return node.body !== undefined;\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n      return node.parent.kind === ts.SyntaxKind.ObjectLiteralExpression;\n    default:\n      return false;\n  }\n}\nexports.hasOwnThisReference = hasOwnThisReference;\nfunction isFunctionWithBody(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.Constructor:\n      return node.body !== undefined;\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.ArrowFunction:\n      return true;\n    default:\n      return false;\n  }\n}\nexports.isFunctionWithBody = isFunctionWithBody;\n/**\r\n * Iterate over all tokens of `node`\r\n *\r\n * @param node The node whose tokens should be visited\r\n * @param cb Is called for every token contained in `node`\r\n */\nfunction forEachToken(node, cb) {\n  let sourceFile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getSourceFile();\n  const queue = [];\n  while (true) {\n    if (isTokenKind(node.kind)) {\n      cb(node);\n    } else if (node.kind !== ts.SyntaxKind.JSDocComment) {\n      const children = node.getChildren(sourceFile);\n      if (children.length === 1) {\n        node = children[0];\n        continue;\n      }\n      for (let i = children.length - 1; i >= 0; --i) queue.push(children[i]); // add children in reverse order, when we pop the next element from the queue, it's the first child\n    }\n    if (queue.length === 0) break;\n    node = queue.pop();\n  }\n}\nexports.forEachToken = forEachToken;\n/**\r\n * Iterate over all tokens and trivia of `node`\r\n *\r\n * @description JsDoc comments are treated like regular comments\r\n *\r\n * @param node The node whose tokens should be visited\r\n * @param cb Is called for every token contained in `node` and trivia before the token\r\n */\nfunction forEachTokenWithTrivia(node, cb) {\n  let sourceFile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getSourceFile();\n  const fullText = sourceFile.text;\n  const scanner = ts.createScanner(sourceFile.languageVersion, false, sourceFile.languageVariant, fullText);\n  return forEachToken(node, token => {\n    const tokenStart = token.kind === ts.SyntaxKind.JsxText || token.pos === token.end ? token.pos : token.getStart(sourceFile);\n    if (tokenStart !== token.pos) {\n      // we only have to handle trivia before each token. whitespace at the end of the file is followed by EndOfFileToken\n      scanner.setTextPos(token.pos);\n      let kind = scanner.scan();\n      let pos = scanner.getTokenPos();\n      while (pos < tokenStart) {\n        const textPos = scanner.getTextPos();\n        cb(fullText, kind, {\n          pos,\n          end: textPos\n        }, token.parent);\n        if (textPos === tokenStart) break;\n        kind = scanner.scan();\n        pos = scanner.getTokenPos();\n      }\n    }\n    return cb(fullText, token.kind, {\n      end: token.end,\n      pos: tokenStart\n    }, token.parent);\n  }, sourceFile);\n}\nexports.forEachTokenWithTrivia = forEachTokenWithTrivia;\n/** Iterate over all comments owned by `node` or its children */\nfunction forEachComment(node, cb) {\n  let sourceFile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getSourceFile();\n  /* Visit all tokens and skip trivia.\r\n     Comment ranges between tokens are parsed without the need of a scanner.\r\n     forEachTokenWithWhitespace does intentionally not pay attention to the correct comment ownership of nodes as it always\r\n     scans all trivia before each token, which could include trailing comments of the previous token.\r\n     Comment onwership is done right in this function*/\n  const fullText = sourceFile.text;\n  const notJsx = sourceFile.languageVariant !== ts.LanguageVariant.JSX;\n  return forEachToken(node, token => {\n    if (token.pos === token.end) return;\n    if (token.kind !== ts.SyntaxKind.JsxText) ts.forEachLeadingCommentRange(fullText,\n    // skip shebang at position 0\n    token.pos === 0 ? (ts.getShebang(fullText) || '').length : token.pos, commentCallback);\n    if (notJsx || canHaveTrailingTrivia(token)) return ts.forEachTrailingCommentRange(fullText, token.end, commentCallback);\n  }, sourceFile);\n  function commentCallback(pos, end, kind) {\n    cb(fullText, {\n      pos,\n      end,\n      kind\n    });\n  }\n}\nexports.forEachComment = forEachComment;\n/** Exclude trailing positions that would lead to scanning for trivia inside JsxText */\nfunction canHaveTrailingTrivia(token) {\n  switch (token.kind) {\n    case ts.SyntaxKind.CloseBraceToken:\n      // after a JsxExpression inside a JsxElement's body can only be other JsxChild, but no trivia\n      return token.parent.kind !== ts.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);\n    case ts.SyntaxKind.GreaterThanToken:\n      switch (token.parent.kind) {\n        case ts.SyntaxKind.JsxOpeningElement:\n          // if end is not equal, this is part of the type arguments list. in all other cases it would be inside the element body\n          return token.end !== token.parent.end;\n        case ts.SyntaxKind.JsxOpeningFragment:\n          return false;\n        // would be inside the fragment\n        case ts.SyntaxKind.JsxSelfClosingElement:\n          return token.end !== token.parent.end ||\n          // if end is not equal, this is part of the type arguments list\n          !isJsxElementOrFragment(token.parent.parent);\n        // there's only trailing trivia if it's the end of the top element\n        case ts.SyntaxKind.JsxClosingElement:\n        case ts.SyntaxKind.JsxClosingFragment:\n          // there's only trailing trivia if it's the end of the top element\n          return !isJsxElementOrFragment(token.parent.parent.parent);\n      }\n  }\n  return true;\n}\nfunction isJsxElementOrFragment(node) {\n  return node.kind === ts.SyntaxKind.JsxElement || node.kind === ts.SyntaxKind.JsxFragment;\n}\nfunction getLineRanges(sourceFile) {\n  const lineStarts = sourceFile.getLineStarts();\n  const result = [];\n  const length = lineStarts.length;\n  const sourceText = sourceFile.text;\n  let pos = 0;\n  for (let i = 1; i < length; ++i) {\n    const end = lineStarts[i];\n    let lineEnd = end;\n    for (; lineEnd > pos; --lineEnd) if (!ts.isLineBreak(sourceText.charCodeAt(lineEnd - 1))) break;\n    result.push({\n      pos,\n      end,\n      contentLength: lineEnd - pos\n    });\n    pos = end;\n  }\n  result.push({\n    pos,\n    end: sourceFile.end,\n    contentLength: sourceFile.end - pos\n  });\n  return result;\n}\nexports.getLineRanges = getLineRanges;\n/** Get the line break style used in sourceFile. This function only looks at the first line break. If there is none, \\n is assumed. */\nfunction getLineBreakStyle(sourceFile) {\n  const lineStarts = sourceFile.getLineStarts();\n  return lineStarts.length === 1 || lineStarts[1] < 2 || sourceFile.text[lineStarts[1] - 2] !== '\\r' ? '\\n' : '\\r\\n';\n}\nexports.getLineBreakStyle = getLineBreakStyle;\nlet cachedScanner;\nfunction scanToken(text, languageVersion) {\n  if (cachedScanner === undefined) {\n    // cache scanner\n    cachedScanner = ts.createScanner(languageVersion, false, undefined, text);\n  } else {\n    cachedScanner.setScriptTarget(languageVersion);\n    cachedScanner.setText(text);\n  }\n  cachedScanner.scan();\n  return cachedScanner;\n}\n/**\r\n * Determines whether the given text parses as a standalone identifier.\r\n * This is not a guarantee that it works in every context. The property name in PropertyAccessExpressions for example allows reserved words.\r\n * Depending on the context it could be parsed as contextual keyword or TypeScript keyword.\r\n */\nfunction isValidIdentifier(text) {\n  let languageVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ts.ScriptTarget.Latest;\n  const scan = scanToken(text, languageVersion);\n  return scan.isIdentifier() && scan.getTextPos() === text.length && scan.getTokenPos() === 0;\n}\nexports.isValidIdentifier = isValidIdentifier;\nfunction charSize(ch) {\n  return ch >= 0x10000 ? 2 : 1;\n}\n/**\r\n * Determines whether the given text can be used to access a property with a PropertyAccessExpression while preserving the property's name.\r\n */\nfunction isValidPropertyAccess(text) {\n  let languageVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ts.ScriptTarget.Latest;\n  if (text.length === 0) return false;\n  let ch = text.codePointAt(0);\n  if (!ts.isIdentifierStart(ch, languageVersion)) return false;\n  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n    ch = text.codePointAt(i);\n    if (!ts.isIdentifierPart(ch, languageVersion)) return false;\n  }\n  return true;\n}\nexports.isValidPropertyAccess = isValidPropertyAccess;\n/**\r\n * Determines whether the given text can be used as unquoted name of a property declaration while preserving the property's name.\r\n */\nfunction isValidPropertyName(text) {\n  let languageVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ts.ScriptTarget.Latest;\n  if (isValidPropertyAccess(text, languageVersion)) return true;\n  const scan = scanToken(text, languageVersion);\n  return scan.getTextPos() === text.length && scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTokenValue() === text; // ensure stringified number equals literal\n}\nexports.isValidPropertyName = isValidPropertyName;\n/**\r\n * Determines whether the given text can be parsed as a numeric literal.\r\n */\nfunction isValidNumericLiteral(text) {\n  let languageVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ts.ScriptTarget.Latest;\n  const scan = scanToken(text, languageVersion);\n  return scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTextPos() === text.length && scan.getTokenPos() === 0;\n}\nexports.isValidNumericLiteral = isValidNumericLiteral;\n/**\r\n * Determines whether the given text can be used as JSX tag or attribute name while preserving the exact name.\r\n */\nfunction isValidJsxIdentifier(text) {\n  let languageVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ts.ScriptTarget.Latest;\n  if (text.length === 0) return false;\n  let seenNamespaceSeparator = false;\n  let ch = text.codePointAt(0);\n  if (!ts.isIdentifierStart(ch, languageVersion)) return false;\n  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n    ch = text.codePointAt(i);\n    if (!ts.isIdentifierPart(ch, languageVersion) && ch !== 45 /* minus */) {\n      if (!seenNamespaceSeparator && ch === 58 /* colon */ && i + charSize(ch) !== text.length) {\n        seenNamespaceSeparator = true;\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nexports.isValidJsxIdentifier = isValidJsxIdentifier;\nfunction isNumericPropertyName(name) {\n  return String(+name) === name;\n}\nexports.isNumericPropertyName = isNumericPropertyName;\nfunction isSameLine(sourceFile, pos1, pos2) {\n  return ts.getLineAndCharacterOfPosition(sourceFile, pos1).line === ts.getLineAndCharacterOfPosition(sourceFile, pos2).line;\n}\nexports.isSameLine = isSameLine;\nvar SideEffectOptions;\n(function (SideEffectOptions) {\n  SideEffectOptions[SideEffectOptions[\"None\"] = 0] = \"None\";\n  SideEffectOptions[SideEffectOptions[\"TaggedTemplate\"] = 1] = \"TaggedTemplate\";\n  SideEffectOptions[SideEffectOptions[\"Constructor\"] = 2] = \"Constructor\";\n  SideEffectOptions[SideEffectOptions[\"JsxElement\"] = 4] = \"JsxElement\";\n})(SideEffectOptions = exports.SideEffectOptions || (exports.SideEffectOptions = {}));\nfunction hasSideEffects(node, options) {\n  var _a, _b;\n  const queue = [];\n  while (true) {\n    switch (node.kind) {\n      case ts.SyntaxKind.CallExpression:\n      case ts.SyntaxKind.PostfixUnaryExpression:\n      case ts.SyntaxKind.AwaitExpression:\n      case ts.SyntaxKind.YieldExpression:\n      case ts.SyntaxKind.DeleteExpression:\n        return true;\n      case ts.SyntaxKind.TypeAssertionExpression:\n      case ts.SyntaxKind.AsExpression:\n      case ts.SyntaxKind.ParenthesizedExpression:\n      case ts.SyntaxKind.NonNullExpression:\n      case ts.SyntaxKind.VoidExpression:\n      case ts.SyntaxKind.TypeOfExpression:\n      case ts.SyntaxKind.PropertyAccessExpression:\n      case ts.SyntaxKind.SpreadElement:\n      case ts.SyntaxKind.PartiallyEmittedExpression:\n        node = node.expression;\n        continue;\n      case ts.SyntaxKind.BinaryExpression:\n        if (isAssignmentKind(node.operatorToken.kind)) return true;\n        queue.push(node.right);\n        node = node.left;\n        continue;\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        switch (node.operator) {\n          case ts.SyntaxKind.PlusPlusToken:\n          case ts.SyntaxKind.MinusMinusToken:\n            return true;\n          default:\n            node = node.operand;\n            continue;\n        }\n      case ts.SyntaxKind.ElementAccessExpression:\n        if (node.argumentExpression !== undefined)\n          // for compatibility with typescript@<2.9.0\n          queue.push(node.argumentExpression);\n        node = node.expression;\n        continue;\n      case ts.SyntaxKind.ConditionalExpression:\n        queue.push(node.whenTrue, node.whenFalse);\n        node = node.condition;\n        continue;\n      case ts.SyntaxKind.NewExpression:\n        if (options & 2 /* Constructor */) return true;\n        if (node.arguments !== undefined) queue.push(...node.arguments);\n        node = node.expression;\n        continue;\n      case ts.SyntaxKind.TaggedTemplateExpression:\n        if (options & 1 /* TaggedTemplate */) return true;\n        queue.push(node.tag);\n        node = node.template;\n        if (node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) break;\n      // falls through\n      case ts.SyntaxKind.TemplateExpression:\n        for (const child of node.templateSpans) queue.push(child.expression);\n        break;\n      case ts.SyntaxKind.ClassExpression:\n        {\n          if (node.decorators !== undefined) return true;\n          for (const child of node.members) {\n            if (child.decorators !== undefined) return true;\n            if (!hasModifier(child.modifiers, ts.SyntaxKind.DeclareKeyword)) {\n              if (((_a = child.name) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.ComputedPropertyName) queue.push(child.name.expression);\n              if (node_1.isMethodDeclaration(child)) {\n                for (const p of child.parameters) if (p.decorators !== undefined) return true;\n              } else if (node_1.isPropertyDeclaration(child) && child.initializer !== undefined && hasModifier(child.modifiers, ts.SyntaxKind.StaticKeyword)) {\n                queue.push(child.initializer);\n              }\n            }\n          }\n          const base = getBaseOfClassLikeExpression(node);\n          if (base === undefined) break;\n          node = base.expression;\n          continue;\n        }\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        queue.push(...node.elements);\n        break;\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        for (const child of node.properties) {\n          if (((_b = child.name) === null || _b === void 0 ? void 0 : _b.kind) === ts.SyntaxKind.ComputedPropertyName) queue.push(child.name.expression);\n          switch (child.kind) {\n            case ts.SyntaxKind.PropertyAssignment:\n              queue.push(child.initializer);\n              break;\n            case ts.SyntaxKind.SpreadAssignment:\n              queue.push(child.expression);\n          }\n        }\n        break;\n      case ts.SyntaxKind.JsxExpression:\n        if (node.expression === undefined) break;\n        node = node.expression;\n        continue;\n      case ts.SyntaxKind.JsxElement:\n      case ts.SyntaxKind.JsxFragment:\n        for (const child of node.children) if (child.kind !== ts.SyntaxKind.JsxText) queue.push(child);\n        if (node.kind === ts.SyntaxKind.JsxFragment) break;\n        node = node.openingElement;\n      // falls through\n      case ts.SyntaxKind.JsxSelfClosingElement:\n      case ts.SyntaxKind.JsxOpeningElement:\n        if (options & 4 /* JsxElement */) return true;\n        for (const child of node.attributes.properties) {\n          if (child.kind === ts.SyntaxKind.JsxSpreadAttribute) {\n            queue.push(child.expression);\n          } else if (child.initializer !== undefined) {\n            queue.push(child.initializer);\n          }\n        }\n        break;\n      case ts.SyntaxKind.CommaListExpression:\n        queue.push(...node.elements);\n    }\n    if (queue.length === 0) return false;\n    node = queue.pop();\n  }\n}\nexports.hasSideEffects = hasSideEffects;\n/** Returns the VariableDeclaration or ParameterDeclaration that contains the BindingElement */\nfunction getDeclarationOfBindingElement(node) {\n  let parent = node.parent.parent;\n  while (parent.kind === ts.SyntaxKind.BindingElement) parent = parent.parent.parent;\n  return parent;\n}\nexports.getDeclarationOfBindingElement = getDeclarationOfBindingElement;\nfunction isExpressionValueUsed(node) {\n  while (true) {\n    const parent = node.parent;\n    switch (parent.kind) {\n      case ts.SyntaxKind.CallExpression:\n      case ts.SyntaxKind.NewExpression:\n      case ts.SyntaxKind.ElementAccessExpression:\n      case ts.SyntaxKind.WhileStatement:\n      case ts.SyntaxKind.DoStatement:\n      case ts.SyntaxKind.WithStatement:\n      case ts.SyntaxKind.ThrowStatement:\n      case ts.SyntaxKind.ReturnStatement:\n      case ts.SyntaxKind.JsxExpression:\n      case ts.SyntaxKind.JsxSpreadAttribute:\n      case ts.SyntaxKind.JsxElement:\n      case ts.SyntaxKind.JsxFragment:\n      case ts.SyntaxKind.JsxSelfClosingElement:\n      case ts.SyntaxKind.ComputedPropertyName:\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.ExportSpecifier:\n      case ts.SyntaxKind.ExportAssignment:\n      case ts.SyntaxKind.ImportDeclaration:\n      case ts.SyntaxKind.ExternalModuleReference:\n      case ts.SyntaxKind.Decorator:\n      case ts.SyntaxKind.TaggedTemplateExpression:\n      case ts.SyntaxKind.TemplateSpan:\n      case ts.SyntaxKind.ExpressionWithTypeArguments:\n      case ts.SyntaxKind.TypeOfExpression:\n      case ts.SyntaxKind.AwaitExpression:\n      case ts.SyntaxKind.YieldExpression:\n      case ts.SyntaxKind.LiteralType:\n      case ts.SyntaxKind.JsxAttributes:\n      case ts.SyntaxKind.JsxOpeningElement:\n      case ts.SyntaxKind.JsxClosingElement:\n      case ts.SyntaxKind.IfStatement:\n      case ts.SyntaxKind.CaseClause:\n      case ts.SyntaxKind.SwitchStatement:\n        return true;\n      case ts.SyntaxKind.PropertyAccessExpression:\n        return parent.expression === node;\n      case ts.SyntaxKind.QualifiedName:\n        return parent.left === node;\n      case ts.SyntaxKind.ShorthandPropertyAssignment:\n        return parent.objectAssignmentInitializer === node || !isInDestructuringAssignment(parent);\n      case ts.SyntaxKind.PropertyAssignment:\n        return parent.initializer === node && !isInDestructuringAssignment(parent);\n      case ts.SyntaxKind.SpreadAssignment:\n      case ts.SyntaxKind.SpreadElement:\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        return !isInDestructuringAssignment(parent);\n      case ts.SyntaxKind.ParenthesizedExpression:\n      case ts.SyntaxKind.AsExpression:\n      case ts.SyntaxKind.TypeAssertionExpression:\n      case ts.SyntaxKind.PostfixUnaryExpression:\n      case ts.SyntaxKind.PrefixUnaryExpression:\n      case ts.SyntaxKind.NonNullExpression:\n        node = parent;\n        continue;\n      case ts.SyntaxKind.ForStatement:\n        return parent.condition === node;\n      case ts.SyntaxKind.ForInStatement:\n      case ts.SyntaxKind.ForOfStatement:\n        return parent.expression === node;\n      case ts.SyntaxKind.ConditionalExpression:\n        if (parent.condition === node) return true;\n        node = parent;\n        break;\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.BindingElement:\n      case ts.SyntaxKind.VariableDeclaration:\n      case ts.SyntaxKind.Parameter:\n      case ts.SyntaxKind.EnumMember:\n        return parent.initializer === node;\n      case ts.SyntaxKind.ImportEqualsDeclaration:\n        return parent.moduleReference === node;\n      case ts.SyntaxKind.CommaListExpression:\n        if (parent.elements[parent.elements.length - 1] !== node) return false;\n        node = parent;\n        break;\n      case ts.SyntaxKind.BinaryExpression:\n        if (parent.right === node) {\n          if (parent.operatorToken.kind === ts.SyntaxKind.CommaToken) {\n            node = parent;\n            break;\n          }\n          return true;\n        }\n        switch (parent.operatorToken.kind) {\n          case ts.SyntaxKind.CommaToken:\n          case ts.SyntaxKind.EqualsToken:\n            return false;\n          case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          case ts.SyntaxKind.EqualsEqualsToken:\n          case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          case ts.SyntaxKind.ExclamationEqualsToken:\n          case ts.SyntaxKind.InstanceOfKeyword:\n          case ts.SyntaxKind.PlusToken:\n          case ts.SyntaxKind.MinusToken:\n          case ts.SyntaxKind.AsteriskToken:\n          case ts.SyntaxKind.SlashToken:\n          case ts.SyntaxKind.PercentToken:\n          case ts.SyntaxKind.AsteriskAsteriskToken:\n          case ts.SyntaxKind.GreaterThanToken:\n          case ts.SyntaxKind.GreaterThanGreaterThanToken:\n          case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n          case ts.SyntaxKind.GreaterThanEqualsToken:\n          case ts.SyntaxKind.LessThanToken:\n          case ts.SyntaxKind.LessThanLessThanToken:\n          case ts.SyntaxKind.LessThanEqualsToken:\n          case ts.SyntaxKind.AmpersandToken:\n          case ts.SyntaxKind.BarToken:\n          case ts.SyntaxKind.CaretToken:\n          case ts.SyntaxKind.BarBarToken:\n          case ts.SyntaxKind.AmpersandAmpersandToken:\n          case ts.SyntaxKind.QuestionQuestionToken:\n          case ts.SyntaxKind.InKeyword:\n          case ts.SyntaxKind.QuestionQuestionEqualsToken:\n          case ts.SyntaxKind.AmpersandAmpersandEqualsToken:\n          case ts.SyntaxKind.BarBarEqualsToken:\n            return true;\n          default:\n            node = parent;\n        }\n        break;\n      default:\n        return false;\n    }\n  }\n}\nexports.isExpressionValueUsed = isExpressionValueUsed;\nfunction isInDestructuringAssignment(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n      if (node.objectAssignmentInitializer !== undefined) return true;\n    // falls through\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.SpreadAssignment:\n      node = node.parent;\n      break;\n    case ts.SyntaxKind.SpreadElement:\n      if (node.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression) return false;\n      node = node.parent;\n  }\n  while (true) {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.BinaryExpression:\n        return node.parent.left === node && node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n      case ts.SyntaxKind.ForOfStatement:\n        return node.parent.initializer === node;\n      case ts.SyntaxKind.ArrayLiteralExpression:\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        node = node.parent;\n        break;\n      case ts.SyntaxKind.SpreadAssignment:\n      case ts.SyntaxKind.PropertyAssignment:\n        node = node.parent.parent;\n        break;\n      case ts.SyntaxKind.SpreadElement:\n        if (node.parent.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression) return false;\n        node = node.parent.parent;\n        break;\n      default:\n        return false;\n    }\n  }\n}\nvar AccessKind;\n(function (AccessKind) {\n  AccessKind[AccessKind[\"None\"] = 0] = \"None\";\n  AccessKind[AccessKind[\"Read\"] = 1] = \"Read\";\n  AccessKind[AccessKind[\"Write\"] = 2] = \"Write\";\n  AccessKind[AccessKind[\"Delete\"] = 4] = \"Delete\";\n  AccessKind[AccessKind[\"ReadWrite\"] = 3] = \"ReadWrite\";\n  AccessKind[AccessKind[\"Modification\"] = 6] = \"Modification\";\n})(AccessKind = exports.AccessKind || (exports.AccessKind = {}));\nfunction getAccessKind(node) {\n  const parent = node.parent;\n  switch (parent.kind) {\n    case ts.SyntaxKind.DeleteExpression:\n      return 4 /* Delete */;\n    case ts.SyntaxKind.PostfixUnaryExpression:\n      return 3 /* ReadWrite */;\n    case ts.SyntaxKind.PrefixUnaryExpression:\n      return parent.operator === ts.SyntaxKind.PlusPlusToken || parent.operator === ts.SyntaxKind.MinusMinusToken ? 3 /* ReadWrite */ : 1 /* Read */;\n    case ts.SyntaxKind.BinaryExpression:\n      return parent.right === node ? 1 /* Read */ : !isAssignmentKind(parent.operatorToken.kind) ? 1 /* Read */ : parent.operatorToken.kind === ts.SyntaxKind.EqualsToken ? 2 /* Write */ : 3 /* ReadWrite */;\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n      return parent.objectAssignmentInitializer === node ? 1 /* Read */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;\n    case ts.SyntaxKind.PropertyAssignment:\n      return parent.name === node ? 0 /* None */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;\n    case ts.SyntaxKind.ArrayLiteralExpression:\n    case ts.SyntaxKind.SpreadElement:\n    case ts.SyntaxKind.SpreadAssignment:\n      return isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;\n    case ts.SyntaxKind.ParenthesizedExpression:\n    case ts.SyntaxKind.NonNullExpression:\n    case ts.SyntaxKind.TypeAssertionExpression:\n    case ts.SyntaxKind.AsExpression:\n      // (<number>foo! as {})++\n      return getAccessKind(parent);\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.ForInStatement:\n      return parent.initializer === node ? 2 /* Write */ : 1 /* Read */;\n    case ts.SyntaxKind.ExpressionWithTypeArguments:\n      return parent.parent.token === ts.SyntaxKind.ExtendsKeyword && parent.parent.parent.kind !== ts.SyntaxKind.InterfaceDeclaration ? 1 /* Read */ : 0 /* None */;\n    case ts.SyntaxKind.ComputedPropertyName:\n    case ts.SyntaxKind.ExpressionStatement:\n    case ts.SyntaxKind.TypeOfExpression:\n    case ts.SyntaxKind.ElementAccessExpression:\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.IfStatement:\n    case ts.SyntaxKind.DoStatement:\n    case ts.SyntaxKind.WhileStatement:\n    case ts.SyntaxKind.SwitchStatement:\n    case ts.SyntaxKind.WithStatement:\n    case ts.SyntaxKind.ThrowStatement:\n    case ts.SyntaxKind.CallExpression:\n    case ts.SyntaxKind.NewExpression:\n    case ts.SyntaxKind.TaggedTemplateExpression:\n    case ts.SyntaxKind.JsxExpression:\n    case ts.SyntaxKind.Decorator:\n    case ts.SyntaxKind.TemplateSpan:\n    case ts.SyntaxKind.JsxOpeningElement:\n    case ts.SyntaxKind.JsxSelfClosingElement:\n    case ts.SyntaxKind.JsxSpreadAttribute:\n    case ts.SyntaxKind.VoidExpression:\n    case ts.SyntaxKind.ReturnStatement:\n    case ts.SyntaxKind.AwaitExpression:\n    case ts.SyntaxKind.YieldExpression:\n    case ts.SyntaxKind.ConditionalExpression:\n    case ts.SyntaxKind.CaseClause:\n    case ts.SyntaxKind.JsxElement:\n      return 1 /* Read */;\n    case ts.SyntaxKind.ArrowFunction:\n      return parent.body === node ? 1 /* Read */ : 2 /* Write */;\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.VariableDeclaration:\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.BindingElement:\n    case ts.SyntaxKind.JsxAttribute:\n      return parent.initializer === node ? 1 /* Read */ : 0 /* None */;\n    case ts.SyntaxKind.PropertyAccessExpression:\n      return parent.expression === node ? 1 /* Read */ : 0 /* None */;\n    case ts.SyntaxKind.ExportAssignment:\n      return parent.isExportEquals ? 1 /* Read */ : 0 /* None */;\n  }\n  return 0 /* None */;\n}\nexports.getAccessKind = getAccessKind;\nfunction isReassignmentTarget(node) {\n  return (getAccessKind(node) & 2 /* Write */) !== 0;\n}\nexports.isReassignmentTarget = isReassignmentTarget;\nfunction canHaveJsDoc(node) {\n  const kind = node.kind;\n  switch (kind) {\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.CallSignature:\n    case ts.SyntaxKind.ConstructSignature:\n    case ts.SyntaxKind.MethodSignature:\n    case ts.SyntaxKind.PropertySignature:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.ParenthesizedExpression:\n    case ts.SyntaxKind.SpreadAssignment:\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.LabeledStatement:\n    case ts.SyntaxKind.ExpressionStatement:\n    case ts.SyntaxKind.VariableStatement:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.Constructor:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.ModuleDeclaration:\n    case ts.SyntaxKind.ImportEqualsDeclaration:\n    case ts.SyntaxKind.ImportDeclaration:\n    case ts.SyntaxKind.NamespaceExportDeclaration:\n    case ts.SyntaxKind.ExportAssignment:\n    case ts.SyntaxKind.IndexSignature:\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.ConstructorType:\n    case ts.SyntaxKind.JSDocFunctionType:\n    case ts.SyntaxKind.ExportDeclaration:\n    case ts.SyntaxKind.NamedTupleMember:\n    case ts.SyntaxKind.EndOfFileToken:\n      return true;\n    default:\n      return false;\n  }\n}\nexports.canHaveJsDoc = canHaveJsDoc;\n/** Gets the JSDoc of a node. For performance reasons this function should only be called when `canHaveJsDoc` returns true. */\nfunction getJsDoc(node, sourceFile) {\n  const result = [];\n  for (const child of node.getChildren(sourceFile)) {\n    if (!node_1.isJsDoc(child)) break;\n    result.push(child);\n  }\n  return result;\n}\nexports.getJsDoc = getJsDoc;\n/**\r\n * Parses the JsDoc of any node. This function is made for nodes that don't get their JsDoc parsed by the TypeScript parser.\r\n *\r\n * @param considerTrailingComments When set to `true` this function uses the trailing comments if the node starts on the same line\r\n *                                 as the previous node ends.\r\n */\nfunction parseJsDocOfNode(node, considerTrailingComments) {\n  let sourceFile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getSourceFile();\n  if (canHaveJsDoc(node) && node.kind !== ts.SyntaxKind.EndOfFileToken) {\n    const result = getJsDoc(node, sourceFile);\n    if (result.length !== 0 || !considerTrailingComments) return result;\n  }\n  return parseJsDocWorker(node, node.getStart(sourceFile), sourceFile, considerTrailingComments);\n}\nexports.parseJsDocOfNode = parseJsDocOfNode;\nfunction parseJsDocWorker(node, nodeStart, sourceFile, considerTrailingComments) {\n  const start = ts[considerTrailingComments && isSameLine(sourceFile, node.pos, nodeStart) ? 'forEachTrailingCommentRange' : 'forEachLeadingCommentRange'](sourceFile.text, node.pos,\n  // return object to make `0` a truthy value\n  (pos, _end, kind) => kind === ts.SyntaxKind.MultiLineCommentTrivia && sourceFile.text[pos + 2] === '*' ? {\n    pos\n  } : undefined);\n  if (start === undefined) return [];\n  const startPos = start.pos;\n  const text = sourceFile.text.slice(startPos, nodeStart);\n  const newSourceFile = ts.createSourceFile('jsdoc.ts', `${text}var a;`, sourceFile.languageVersion);\n  const result = getJsDoc(newSourceFile.statements[0], newSourceFile);\n  for (const doc of result) updateNode(doc, node);\n  return result;\n  function updateNode(n, parent) {\n    n.pos += startPos;\n    n.end += startPos;\n    n.parent = parent;\n    return ts.forEachChild(n, child => updateNode(child, n), children => {\n      children.pos += startPos;\n      children.end += startPos;\n      for (const child of children) updateNode(child, n);\n    });\n  }\n}\nvar ImportKind;\n(function (ImportKind) {\n  ImportKind[ImportKind[\"ImportDeclaration\"] = 1] = \"ImportDeclaration\";\n  ImportKind[ImportKind[\"ImportEquals\"] = 2] = \"ImportEquals\";\n  ImportKind[ImportKind[\"ExportFrom\"] = 4] = \"ExportFrom\";\n  ImportKind[ImportKind[\"DynamicImport\"] = 8] = \"DynamicImport\";\n  ImportKind[ImportKind[\"Require\"] = 16] = \"Require\";\n  ImportKind[ImportKind[\"ImportType\"] = 32] = \"ImportType\";\n  ImportKind[ImportKind[\"All\"] = 63] = \"All\";\n  ImportKind[ImportKind[\"AllImports\"] = 59] = \"AllImports\";\n  ImportKind[ImportKind[\"AllStaticImports\"] = 3] = \"AllStaticImports\";\n  ImportKind[ImportKind[\"AllImportExpressions\"] = 24] = \"AllImportExpressions\";\n  ImportKind[ImportKind[\"AllRequireLike\"] = 18] = \"AllRequireLike\";\n  // @internal\n  ImportKind[ImportKind[\"AllNestedImports\"] = 56] = \"AllNestedImports\";\n  // @internal\n  ImportKind[ImportKind[\"AllTopLevelImports\"] = 7] = \"AllTopLevelImports\";\n})(ImportKind = exports.ImportKind || (exports.ImportKind = {}));\nfunction findImports(sourceFile, kinds) {\n  let ignoreFileName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const result = [];\n  for (const node of findImportLikeNodes(sourceFile, kinds, ignoreFileName)) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ImportDeclaration:\n        addIfTextualLiteral(node.moduleSpecifier);\n        break;\n      case ts.SyntaxKind.ImportEqualsDeclaration:\n        addIfTextualLiteral(node.moduleReference.expression);\n        break;\n      case ts.SyntaxKind.ExportDeclaration:\n        addIfTextualLiteral(node.moduleSpecifier);\n        break;\n      case ts.SyntaxKind.CallExpression:\n        addIfTextualLiteral(node.arguments[0]);\n        break;\n      case ts.SyntaxKind.ImportType:\n        if (node_1.isLiteralTypeNode(node.argument)) addIfTextualLiteral(node.argument.literal);\n        break;\n      default:\n        throw new Error('unexpected node');\n    }\n  }\n  return result;\n  function addIfTextualLiteral(node) {\n    if (node_1.isTextualLiteral(node)) result.push(node);\n  }\n}\nexports.findImports = findImports;\nfunction findImportLikeNodes(sourceFile, kinds) {\n  let ignoreFileName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return new ImportFinder(sourceFile, kinds, ignoreFileName).find();\n}\nexports.findImportLikeNodes = findImportLikeNodes;\nclass ImportFinder {\n  constructor(_sourceFile, _options, _ignoreFileName) {\n    this._sourceFile = _sourceFile;\n    this._options = _options;\n    this._ignoreFileName = _ignoreFileName;\n    this._result = [];\n  }\n  find() {\n    if (this._sourceFile.isDeclarationFile) this._options &= ~24 /* AllImportExpressions */;\n    if (this._options & 7 /* AllTopLevelImports */) this._findImports(this._sourceFile.statements);\n    if (this._options & 56 /* AllNestedImports */) this._findNestedImports();\n    return this._result;\n  }\n  _findImports(statements) {\n    for (const statement of statements) {\n      if (node_1.isImportDeclaration(statement)) {\n        if (this._options & 1 /* ImportDeclaration */) this._result.push(statement);\n      } else if (node_1.isImportEqualsDeclaration(statement)) {\n        if (this._options & 2 /* ImportEquals */ && statement.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) this._result.push(statement);\n      } else if (node_1.isExportDeclaration(statement)) {\n        if (statement.moduleSpecifier !== undefined && this._options & 4 /* ExportFrom */) this._result.push(statement);\n      } else if (node_1.isModuleDeclaration(statement)) {\n        this._findImportsInModule(statement);\n      }\n    }\n  }\n  _findImportsInModule(declaration) {\n    if (declaration.body === undefined) return;\n    if (declaration.body.kind === ts.SyntaxKind.ModuleDeclaration) return this._findImportsInModule(declaration.body);\n    this._findImports(declaration.body.statements);\n  }\n  _findNestedImports() {\n    const isJavaScriptFile = this._ignoreFileName || (this._sourceFile.flags & ts.NodeFlags.JavaScriptFile) !== 0;\n    let re;\n    let includeJsDoc;\n    if ((this._options & 56 /* AllNestedImports */) === 16 /* Require */) {\n      if (!isJavaScriptFile) return; // don't look for 'require' in TS files\n      re = /\\brequire\\s*[</(]/g;\n      includeJsDoc = false;\n    } else if (this._options & 16 /* Require */ && isJavaScriptFile) {\n      re = /\\b(?:import|require)\\s*[</(]/g;\n      includeJsDoc = (this._options & 32 /* ImportType */) !== 0;\n    } else {\n      re = /\\bimport\\s*[</(]/g;\n      includeJsDoc = isJavaScriptFile && (this._options & 32 /* ImportType */) !== 0;\n    }\n    for (let match = re.exec(this._sourceFile.text); match !== null; match = re.exec(this._sourceFile.text)) {\n      const token = getTokenAtPositionWorker(this._sourceFile, match.index, this._sourceFile,\n      // only look for ImportTypeNode within JSDoc in JS files\n      match[0][0] === 'i' && includeJsDoc);\n      if (token.kind === ts.SyntaxKind.ImportKeyword) {\n        if (token.end - 'import'.length !== match.index) continue;\n        switch (token.parent.kind) {\n          case ts.SyntaxKind.ImportType:\n            this._result.push(token.parent);\n            break;\n          case ts.SyntaxKind.CallExpression:\n            if (token.parent.arguments.length > 1) this._result.push(token.parent);\n        }\n      } else if (token.kind === ts.SyntaxKind.Identifier && token.end - 'require'.length === match.index && token.parent.kind === ts.SyntaxKind.CallExpression && token.parent.expression === token && token.parent.arguments.length === 1) {\n        this._result.push(token.parent);\n      }\n    }\n  }\n}\n/**\r\n * Ambient context means the statement itself has the `declare` keyword\r\n * or is inside a `declare namespace`,  `delcare module` or `declare global`.\r\n */\nfunction isStatementInAmbientContext(node) {\n  while (node.flags & ts.NodeFlags.NestedNamespace) node = node.parent;\n  return hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword) || isAmbientModuleBlock(node.parent);\n}\nexports.isStatementInAmbientContext = isStatementInAmbientContext;\n/** Includes `declare namespace`, `declare module` and `declare global` and namespace nested in one of the aforementioned. */\nfunction isAmbientModuleBlock(node) {\n  while (node.kind === ts.SyntaxKind.ModuleBlock) {\n    do node = node.parent; while (node.flags & ts.NodeFlags.NestedNamespace);\n    if (hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword)) return true;\n    node = node.parent;\n  }\n  return false;\n}\nexports.isAmbientModuleBlock = isAmbientModuleBlock;\nfunction getIIFE(func) {\n  let node = func.parent;\n  while (node.kind === ts.SyntaxKind.ParenthesizedExpression) node = node.parent;\n  return node_1.isCallExpression(node) && func.end <= node.expression.end ? node : undefined;\n}\nexports.getIIFE = getIIFE;\nfunction isStrictCompilerOptionEnabled(options, option) {\n  return (options.strict ? options[option] !== false : options[option] === true) && (option !== 'strictPropertyInitialization' || isStrictCompilerOptionEnabled(options, 'strictNullChecks'));\n}\nexports.isStrictCompilerOptionEnabled = isStrictCompilerOptionEnabled;\n// https://github.com/ajafff/tslint-consistent-codestyle/issues/85\n/**\r\n * Checks if a given compiler option is enabled.\r\n * It handles dependencies of options, e.g. `declaration` is implicitly enabled by `composite` or `strictNullChecks` is enabled by `strict`.\r\n * However, it does not check dependencies that are already checked and reported as errors, e.g. `checkJs` without `allowJs`.\r\n * This function only handles boolean flags.\r\n */\nfunction isCompilerOptionEnabled(options, option) {\n  switch (option) {\n    case 'stripInternal':\n    case 'declarationMap':\n    case 'emitDeclarationOnly':\n      return options[option] === true && isCompilerOptionEnabled(options, 'declaration');\n    case 'declaration':\n      return options.declaration || isCompilerOptionEnabled(options, 'composite');\n    case 'incremental':\n      return options.incremental === undefined ? isCompilerOptionEnabled(options, 'composite') : options.incremental;\n    case 'skipDefaultLibCheck':\n      return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, 'skipLibCheck');\n    case 'suppressImplicitAnyIndexErrors':\n      return options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, 'noImplicitAny');\n    case 'allowSyntheticDefaultImports':\n      return options.allowSyntheticDefaultImports !== undefined ? options.allowSyntheticDefaultImports : isCompilerOptionEnabled(options, 'esModuleInterop') || options.module === ts.ModuleKind.System;\n    case 'noUncheckedIndexedAccess':\n      return options.noUncheckedIndexedAccess === true && isCompilerOptionEnabled(options, 'strictNullChecks');\n    case 'allowJs':\n      return options.allowJs === undefined ? isCompilerOptionEnabled(options, 'checkJs') : options.allowJs;\n    case 'noImplicitAny':\n    case 'noImplicitThis':\n    case 'strictNullChecks':\n    case 'strictFunctionTypes':\n    case 'strictPropertyInitialization':\n    case 'alwaysStrict':\n    case 'strictBindCallApply':\n      return isStrictCompilerOptionEnabled(options, option);\n  }\n  return options[option] === true;\n}\nexports.isCompilerOptionEnabled = isCompilerOptionEnabled;\n/**\r\n * Has nothing to do with `isAmbientModuleBlock`.\r\n *\r\n * @returns `true` if it's a global augmentation or has a string name.\r\n */\nfunction isAmbientModule(node) {\n  return node.name.kind === ts.SyntaxKind.StringLiteral || (node.flags & ts.NodeFlags.GlobalAugmentation) !== 0;\n}\nexports.isAmbientModule = isAmbientModule;\n/**\r\n * @deprecated use `getTsCheckDirective` instead since `// @ts-nocheck` is no longer restricted to JS files.\r\n * @returns the last `// @ts-check` or `// @ts-nocheck` directive in the given file.\r\n */\nfunction getCheckJsDirective(source) {\n  return getTsCheckDirective(source);\n}\nexports.getCheckJsDirective = getCheckJsDirective;\n/** @returns the last `// @ts-check` or `// @ts-nocheck` directive in the given file. */\nfunction getTsCheckDirective(source) {\n  let directive;\n  // needs to work around a shebang issue until https://github.com/Microsoft/TypeScript/issues/28477 is resolved\n  ts.forEachLeadingCommentRange(source, (ts.getShebang(source) || '').length, (pos, end, kind) => {\n    if (kind === ts.SyntaxKind.SingleLineCommentTrivia) {\n      const text = source.slice(pos, end);\n      const match = /^\\/{2,3}\\s*@ts-(no)?check(?:\\s|$)/i.exec(text);\n      if (match !== null) directive = {\n        pos,\n        end,\n        enabled: match[1] === undefined\n      };\n    }\n  });\n  return directive;\n}\nexports.getTsCheckDirective = getTsCheckDirective;\nfunction isConstAssertion(node) {\n  return node_1.isTypeReferenceNode(node.type) && node.type.typeName.kind === ts.SyntaxKind.Identifier && node.type.typeName.escapedText === 'const';\n}\nexports.isConstAssertion = isConstAssertion;\n/** Detects whether an expression is affected by an enclosing 'as const' assertion and therefore treated literally. */\nfunction isInConstContext(node) {\n  let current = node;\n  while (true) {\n    const parent = current.parent;\n    outer: switch (parent.kind) {\n      case ts.SyntaxKind.TypeAssertionExpression:\n      case ts.SyntaxKind.AsExpression:\n        return isConstAssertion(parent);\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        if (current.kind !== ts.SyntaxKind.NumericLiteral) return false;\n        switch (parent.operator) {\n          case ts.SyntaxKind.PlusToken:\n          case ts.SyntaxKind.MinusToken:\n            current = parent;\n            break outer;\n          default:\n            return false;\n        }\n      case ts.SyntaxKind.PropertyAssignment:\n        if (parent.initializer !== current) return false;\n        current = parent.parent;\n        break;\n      case ts.SyntaxKind.ShorthandPropertyAssignment:\n        current = parent.parent;\n        break;\n      case ts.SyntaxKind.ParenthesizedExpression:\n      case ts.SyntaxKind.ArrayLiteralExpression:\n      case ts.SyntaxKind.ObjectLiteralExpression:\n      case ts.SyntaxKind.TemplateExpression:\n        current = parent;\n        break;\n      default:\n        return false;\n    }\n  }\n}\nexports.isInConstContext = isInConstContext;\n/** Returns true for `Object.defineProperty(o, 'prop', {value, writable: false})` and  `Object.defineProperty(o, 'prop', {get: () => 1})`*/\nfunction isReadonlyAssignmentDeclaration(node, checker) {\n  if (!isBindableObjectDefinePropertyCall(node)) return false;\n  const descriptorType = checker.getTypeAtLocation(node.arguments[2]);\n  if (descriptorType.getProperty('value') === undefined) return descriptorType.getProperty('set') === undefined;\n  const writableProp = descriptorType.getProperty('writable');\n  if (writableProp === undefined) return false;\n  const writableType = writableProp.valueDeclaration !== undefined && node_1.isPropertyAssignment(writableProp.valueDeclaration) ? checker.getTypeAtLocation(writableProp.valueDeclaration.initializer) : checker.getTypeOfSymbolAtLocation(writableProp, node.arguments[2]);\n  return type_1.isBooleanLiteralType(writableType, false);\n}\nexports.isReadonlyAssignmentDeclaration = isReadonlyAssignmentDeclaration;\n/** Determines whether a call to `Object.defineProperty` is statically analyzable. */\nfunction isBindableObjectDefinePropertyCall(node) {\n  return node.arguments.length === 3 && node_1.isEntityNameExpression(node.arguments[0]) && node_1.isNumericOrStringLikeLiteral(node.arguments[1]) && node_1.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === 'defineProperty' && node_1.isIdentifier(node.expression.expression) && node.expression.expression.escapedText === 'Object';\n}\nexports.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;\nfunction isWellKnownSymbolLiterally(node) {\n  return ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression) && node.expression.escapedText === 'Symbol';\n}\nexports.isWellKnownSymbolLiterally = isWellKnownSymbolLiterally;\n/** @deprecated typescript 4.3 removed the concept of literal well known symbols. Use `getPropertyNameFromType` instead. */\nfunction getPropertyNameOfWellKnownSymbol(node) {\n  return {\n    displayName: `[Symbol.${node.name.text}]`,\n    symbolName: '__@' + node.name.text\n  };\n}\nexports.getPropertyNameOfWellKnownSymbol = getPropertyNameOfWellKnownSymbol;\nconst isTsBefore43 = (_ref => {\n  let [major, minor] = _ref;\n  return major < '4' || major === '4' && minor < '3';\n})(ts.versionMajorMinor.split('.'));\nfunction getLateBoundPropertyNames(node, checker) {\n  const result = {\n    known: true,\n    names: []\n  };\n  node = unwrapParentheses(node);\n  if (isTsBefore43 && isWellKnownSymbolLiterally(node)) {\n    result.names.push(getPropertyNameOfWellKnownSymbol(node)); // wotan-disable-line no-unstable-api-use\n  } else {\n    const type = checker.getTypeAtLocation(node);\n    for (const key of type_1.unionTypeParts(checker.getBaseConstraintOfType(type) || type)) {\n      const propertyName = type_1.getPropertyNameFromType(key);\n      if (propertyName) {\n        result.names.push(propertyName);\n      } else {\n        result.known = false;\n      }\n    }\n  }\n  return result;\n}\nexports.getLateBoundPropertyNames = getLateBoundPropertyNames;\nfunction getLateBoundPropertyNamesOfPropertyName(node, checker) {\n  const staticName = getPropertyName(node);\n  return staticName !== undefined ? {\n    known: true,\n    names: [{\n      displayName: staticName,\n      symbolName: ts.escapeLeadingUnderscores(staticName)\n    }]\n  } : node.kind === ts.SyntaxKind.PrivateIdentifier ? {\n    known: true,\n    names: [{\n      displayName: node.text,\n      symbolName: checker.getSymbolAtLocation(node).escapedName\n    }]\n  } : getLateBoundPropertyNames(node.expression, checker);\n}\nexports.getLateBoundPropertyNamesOfPropertyName = getLateBoundPropertyNamesOfPropertyName;\n/** Most declarations demand there to be only one statically known name, e.g. class members with computed name. */\nfunction getSingleLateBoundPropertyNameOfPropertyName(node, checker) {\n  const staticName = getPropertyName(node);\n  if (staticName !== undefined) return {\n    displayName: staticName,\n    symbolName: ts.escapeLeadingUnderscores(staticName)\n  };\n  if (node.kind === ts.SyntaxKind.PrivateIdentifier) return {\n    displayName: node.text,\n    symbolName: checker.getSymbolAtLocation(node).escapedName\n  };\n  const {\n    expression\n  } = node;\n  return isTsBefore43 && isWellKnownSymbolLiterally(expression) ? getPropertyNameOfWellKnownSymbol(expression) // wotan-disable-line no-unstable-api-use\n  : type_1.getPropertyNameFromType(checker.getTypeAtLocation(expression));\n}\nexports.getSingleLateBoundPropertyNameOfPropertyName = getSingleLateBoundPropertyNameOfPropertyName;\nfunction unwrapParentheses(node) {\n  while (node.kind === ts.SyntaxKind.ParenthesizedExpression) node = node.expression;\n  return node;\n}\nexports.unwrapParentheses = unwrapParentheses;\nfunction formatPseudoBigInt(v) {\n  return `${v.negative ? '-' : ''}${v.base10Value}n`;\n}\nexports.formatPseudoBigInt = formatPseudoBigInt;\n/**\r\n * Determines whether the given `SwitchStatement`'s `case` clauses cover every possible value of the switched expression.\r\n * The logic is the same as TypeScript's control flow analysis.\r\n * This does **not** check whether all `case` clauses do a certain action like assign a variable or return a value.\r\n * This function ignores the `default` clause if present.\r\n */\nfunction hasExhaustiveCaseClauses(node, checker) {\n  const caseClauses = node.caseBlock.clauses.filter(node_1.isCaseClause);\n  if (caseClauses.length === 0) return false;\n  const typeParts = type_1.unionTypeParts(checker.getTypeAtLocation(node.expression));\n  if (typeParts.length > caseClauses.length) return false;\n  const types = new Set(typeParts.map(getPrimitiveLiteralFromType));\n  if (types.has(undefined)) return false;\n  const seen = new Set();\n  for (const clause of caseClauses) {\n    const expressionType = checker.getTypeAtLocation(clause.expression);\n    if (exports.isTypeFlagSet(expressionType, ts.TypeFlags.Never)) continue; // additional case clause with 'never' is always allowed\n    const type = getPrimitiveLiteralFromType(expressionType);\n    if (types.has(type)) {\n      seen.add(type);\n    } else if (type !== 'null' && type !== 'undefined') {\n      // additional case clauses with 'null' and 'undefined' are always allowed\n      return false;\n    }\n  }\n  return types.size === seen.size;\n}\nexports.hasExhaustiveCaseClauses = hasExhaustiveCaseClauses;\nfunction getPrimitiveLiteralFromType(t) {\n  if (exports.isTypeFlagSet(t, ts.TypeFlags.Null)) return 'null';\n  if (exports.isTypeFlagSet(t, ts.TypeFlags.Undefined)) return 'undefined';\n  if (exports.isTypeFlagSet(t, ts.TypeFlags.NumberLiteral)) return `${exports.isTypeFlagSet(t, ts.TypeFlags.EnumLiteral) ? 'enum:' : ''}${t.value}`;\n  if (exports.isTypeFlagSet(t, ts.TypeFlags.StringLiteral)) return `${exports.isTypeFlagSet(t, ts.TypeFlags.EnumLiteral) ? 'enum:' : ''}string:${t.value}`;\n  if (exports.isTypeFlagSet(t, ts.TypeFlags.BigIntLiteral)) return formatPseudoBigInt(t.value);\n  if (_3_2_1.isUniqueESSymbolType(t)) return t.escapedName;\n  if (type_1.isBooleanLiteralType(t, true)) return 'true';\n  if (type_1.isBooleanLiteralType(t, false)) return 'false';\n}\nfunction getBaseOfClassLikeExpression(node) {\n  var _a;\n  if (((_a = node.heritageClauses) === null || _a === void 0 ? void 0 : _a[0].token) === ts.SyntaxKind.ExtendsKeyword) return node.heritageClauses[0].types[0];\n}\nexports.getBaseOfClassLikeExpression = getBaseOfClassLikeExpression;","map":{"version":3,"mappings":"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","names":["getChildOfKind","node","kind","sourceFile","child","getChildren","exports","isTokenKind","ts","SyntaxKind","FirstToken","LastToken","isNodeKind","FirstNode","isAssignmentKind","FirstAssignment","LastAssignment","isTypeNodeKind","FirstTypeNode","LastTypeNode","isJsDocKind","FirstJSDocNode","LastJSDocNode","isKeywordKind","FirstKeyword","LastKeyword","isThisParameter","parameter","name","Identifier","originalKeywordKind","ThisKeyword","getModifier","modifiers","undefined","modifier","hasModifier","kinds","includes","isParameterProperty","PublicKeyword","ProtectedKeyword","PrivateKeyword","ReadonlyKeyword","hasAccessModifier","isModifierFlagSet","ModifierFlags","AccessibilityModifier","isFlagSet","obj","flag","flags","isObjectFlagSet","objectType","objectFlags","getCombinedModifierFlags","getPreviousStatement","statement","parent","node_1","index","statements","indexOf","getNextStatement","length","getPreviousToken","pos","getTokenAtPositionWorker","getSourceFile","getNextToken","SourceFile","EndOfFileToken","end","endOfFileToken","getTokenAtPosition","allowJsDoc","getAstNodeAtPosition","outer","JSDocComment","getCommentAtPosition","token","JsxText","tokenToString","startPos","getShebang","text","forEachTrailingCommentRange","commentAtPositionCallback","forEachLeadingCommentRange","_nl","at","isPositionInComment","commentText","sourceText","comment","substring","SingleLineCommentTrivia","nested","forEachChild","getWrappedNodeAtPosition","wrap","children","getPropertyName","propertyName","ComputedPropertyName","expression","unwrapParentheses","negate","operator","MinusToken","PlusToken","operand","_3_2_1","slice","PrivateIdentifier","forEachDestructuringIdentifier","pattern","fn","element","elements","BindingElement","result","forEachDeclaredVariable","declarationList","cb","declaration","declarations","VariableDeclarationKind","getVariableDeclarationKind","NodeFlags","Let","Const","isBlockScopedVariableDeclarationList","BlockScoped","isBlockScopedVariableDeclaration","CatchClause","isBlockScopedDeclarationStatement","VariableStatement","ClassDeclaration","EnumDeclaration","InterfaceDeclaration","TypeAliasDeclaration","isInSingleStatementContext","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoStatement","IfStatement","WithStatement","LabeledStatement","ScopeBoundary","ScopeBoundarySelector","isScopeBoundary","isFunctionScopeBoundary","isBlockScopeBoundary","isTypeScopeBoundary","MappedType","ConditionalType","FunctionExpression","ArrowFunction","Constructor","ModuleDeclaration","ClassExpression","MethodDeclaration","FunctionDeclaration","GetAccessor","SetAccessor","MethodSignature","CallSignature","ConstructSignature","ConstructorType","FunctionType","isExternalModule","Block","CaseBlock","hasOwnThisReference","body","ObjectLiteralExpression","isFunctionWithBody","forEachToken","queue","i","push","pop","forEachTokenWithTrivia","fullText","scanner","createScanner","languageVersion","languageVariant","tokenStart","getStart","setTextPos","scan","getTokenPos","textPos","getTextPos","forEachComment","notJsx","LanguageVariant","JSX","commentCallback","canHaveTrailingTrivia","CloseBraceToken","JsxExpression","isJsxElementOrFragment","GreaterThanToken","JsxOpeningElement","JsxOpeningFragment","JsxSelfClosingElement","JsxClosingElement","JsxClosingFragment","JsxElement","JsxFragment","getLineRanges","lineStarts","getLineStarts","lineEnd","isLineBreak","charCodeAt","contentLength","getLineBreakStyle","cachedScanner","scanToken","setScriptTarget","setText","isValidIdentifier","ScriptTarget","Latest","isIdentifier","charSize","ch","isValidPropertyAccess","codePointAt","isIdentifierStart","isIdentifierPart","isValidPropertyName","getToken","NumericLiteral","getTokenValue","isValidNumericLiteral","isValidJsxIdentifier","seenNamespaceSeparator","isNumericPropertyName","String","isSameLine","pos1","pos2","getLineAndCharacterOfPosition","line","SideEffectOptions","hasSideEffects","options","CallExpression","PostfixUnaryExpression","AwaitExpression","YieldExpression","DeleteExpression","TypeAssertionExpression","AsExpression","ParenthesizedExpression","NonNullExpression","VoidExpression","TypeOfExpression","PropertyAccessExpression","SpreadElement","PartiallyEmittedExpression","BinaryExpression","operatorToken","right","left","PrefixUnaryExpression","PlusPlusToken","MinusMinusToken","ElementAccessExpression","argumentExpression","ConditionalExpression","whenTrue","whenFalse","condition","NewExpression","arguments","TaggedTemplateExpression","tag","template","NoSubstitutionTemplateLiteral","TemplateExpression","templateSpans","decorators","members","DeclareKeyword","p","parameters","initializer","StaticKeyword","base","getBaseOfClassLikeExpression","ArrayLiteralExpression","properties","PropertyAssignment","SpreadAssignment","openingElement","attributes","JsxSpreadAttribute","CommaListExpression","getDeclarationOfBindingElement","isExpressionValueUsed","ThrowStatement","ReturnStatement","ExportSpecifier","ExportAssignment","ImportDeclaration","ExternalModuleReference","Decorator","TemplateSpan","ExpressionWithTypeArguments","LiteralType","JsxAttributes","CaseClause","SwitchStatement","QualifiedName","ShorthandPropertyAssignment","objectAssignmentInitializer","isInDestructuringAssignment","PropertyDeclaration","VariableDeclaration","Parameter","EnumMember","ImportEqualsDeclaration","moduleReference","CommaToken","EqualsToken","EqualsEqualsEqualsToken","EqualsEqualsToken","ExclamationEqualsEqualsToken","ExclamationEqualsToken","InstanceOfKeyword","AsteriskToken","SlashToken","PercentToken","AsteriskAsteriskToken","GreaterThanGreaterThanToken","GreaterThanGreaterThanGreaterThanToken","GreaterThanEqualsToken","LessThanToken","LessThanLessThanToken","LessThanEqualsToken","AmpersandToken","BarToken","CaretToken","BarBarToken","AmpersandAmpersandToken","QuestionQuestionToken","InKeyword","QuestionQuestionEqualsToken","AmpersandAmpersandEqualsToken","BarBarEqualsToken","AccessKind","getAccessKind","ExtendsKeyword","ExpressionStatement","JsxAttribute","isExportEquals","isReassignmentTarget","canHaveJsDoc","PropertySignature","NamespaceExportDeclaration","IndexSignature","JSDocFunctionType","ExportDeclaration","NamedTupleMember","getJsDoc","parseJsDocOfNode","considerTrailingComments","parseJsDocWorker","nodeStart","start","_end","MultiLineCommentTrivia","newSourceFile","createSourceFile","doc","updateNode","n","ImportKind","findImports","ignoreFileName","findImportLikeNodes","addIfTextualLiteral","moduleSpecifier","ImportType","argument","literal","Error","ImportFinder","find","constructor","_sourceFile","_options","_ignoreFileName","isDeclarationFile","_findImports","_findNestedImports","_result","_findImportsInModule","isJavaScriptFile","JavaScriptFile","re","includeJsDoc","match","exec","ImportKeyword","isStatementInAmbientContext","NestedNamespace","isAmbientModuleBlock","ModuleBlock","getIIFE","func","isStrictCompilerOptionEnabled","option","strict","isCompilerOptionEnabled","incremental","skipDefaultLibCheck","suppressImplicitAnyIndexErrors","allowSyntheticDefaultImports","module","ModuleKind","System","noUncheckedIndexedAccess","allowJs","isAmbientModule","StringLiteral","GlobalAugmentation","getCheckJsDirective","source","getTsCheckDirective","directive","enabled","isConstAssertion","type","typeName","escapedText","isInConstContext","current","isReadonlyAssignmentDeclaration","checker","isBindableObjectDefinePropertyCall","descriptorType","getTypeAtLocation","getProperty","writableProp","writableType","valueDeclaration","getTypeOfSymbolAtLocation","type_1","isWellKnownSymbolLiterally","isPropertyAccessExpression","getPropertyNameOfWellKnownSymbol","displayName","symbolName","isTsBefore43","_ref","major","minor","versionMajorMinor","split","getLateBoundPropertyNames","known","names","key","getBaseConstraintOfType","getLateBoundPropertyNamesOfPropertyName","staticName","escapeLeadingUnderscores","getSymbolAtLocation","escapedName","getSingleLateBoundPropertyNameOfPropertyName","formatPseudoBigInt","v","negative","base10Value","hasExhaustiveCaseClauses","caseClauses","caseBlock","clauses","filter","typeParts","types","Set","map","getPrimitiveLiteralFromType","has","seen","clause","expressionType","TypeFlags","Never","add","size","t","Null","Undefined","NumberLiteral","EnumLiteral","value","BigIntLiteral","heritageClauses"],"sources":["util.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}