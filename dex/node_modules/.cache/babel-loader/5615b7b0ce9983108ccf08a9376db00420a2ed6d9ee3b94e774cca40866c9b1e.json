{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isThisInTypeQuery = exports.isThisIdentifier = exports.identifierIsThisKeyword = exports.firstDefined = exports.nodeHasTokens = exports.createError = exports.TSError = exports.convertTokens = exports.convertToken = exports.getTokenType = exports.isChildUnwrappableOptionalChain = exports.isChainExpression = exports.isOptional = exports.isComputedProperty = exports.unescapeStringLiteralText = exports.hasJSXAncestor = exports.findFirstMatchingAncestor = exports.findNextToken = exports.getTSNodeAccessibility = exports.getDeclarationKind = exports.isJSXToken = exports.isToken = exports.getRange = exports.canContainDirective = exports.getLocFor = exports.getLineAndCharacterFor = exports.getBinaryExpressionType = exports.isJSDocComment = exports.isComment = exports.isComma = exports.getLastModifier = exports.hasModifier = exports.isESTreeClassMember = exports.getTextForTokenKind = exports.isLogicalOperator = exports.isAssignmentOperator = void 0;\nconst ts = __importStar(require(\"typescript\"));\nconst getModifiers_1 = require(\"./getModifiers\");\nconst xhtml_entities_1 = require(\"./jsx/xhtml-entities\");\nconst ts_estree_1 = require(\"./ts-estree\");\nconst version_check_1 = require(\"./version-check\");\nconst isAtLeast50 = version_check_1.typescriptVersionIsAtLeast['5.0'];\nconst SyntaxKind = ts.SyntaxKind;\nconst LOGICAL_OPERATORS = [SyntaxKind.BarBarToken, SyntaxKind.AmpersandAmpersandToken, SyntaxKind.QuestionQuestionToken];\n/**\n * Returns true if the given ts.Token is the assignment operator\n * @param operator the operator token\n * @returns is assignment\n */\nfunction isAssignmentOperator(operator) {\n  return operator.kind >= SyntaxKind.FirstAssignment && operator.kind <= SyntaxKind.LastAssignment;\n}\nexports.isAssignmentOperator = isAssignmentOperator;\n/**\n * Returns true if the given ts.Token is a logical operator\n * @param operator the operator token\n * @returns is a logical operator\n */\nfunction isLogicalOperator(operator) {\n  return LOGICAL_OPERATORS.includes(operator.kind);\n}\nexports.isLogicalOperator = isLogicalOperator;\n/**\n * Returns the string form of the given TSToken SyntaxKind\n * @param kind the token's SyntaxKind\n * @returns the token applicable token as a string\n */\nfunction getTextForTokenKind(kind) {\n  return ts.tokenToString(kind);\n}\nexports.getTextForTokenKind = getTextForTokenKind;\n/**\n * Returns true if the given ts.Node is a valid ESTree class member\n * @param node TypeScript AST node\n * @returns is valid ESTree class member\n */\nfunction isESTreeClassMember(node) {\n  return node.kind !== SyntaxKind.SemicolonClassElement;\n}\nexports.isESTreeClassMember = isESTreeClassMember;\n/**\n * Checks if a ts.Node has a modifier\n * @param modifierKind TypeScript SyntaxKind modifier\n * @param node TypeScript AST node\n * @returns has the modifier specified\n */\nfunction hasModifier(modifierKind, node) {\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  return (modifiers === null || modifiers === void 0 ? void 0 : modifiers.some(modifier => modifier.kind === modifierKind)) === true;\n}\nexports.hasModifier = hasModifier;\n/**\n * Get last last modifier in ast\n * @param node TypeScript AST node\n * @returns returns last modifier if present or null\n */\nfunction getLastModifier(node) {\n  var _a;\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  if (modifiers == null) {\n    return null;\n  }\n  return (_a = modifiers[modifiers.length - 1]) !== null && _a !== void 0 ? _a : null;\n}\nexports.getLastModifier = getLastModifier;\n/**\n * Returns true if the given ts.Token is a comma\n * @param token the TypeScript token\n * @returns is comma\n */\nfunction isComma(token) {\n  return token.kind === SyntaxKind.CommaToken;\n}\nexports.isComma = isComma;\n/**\n * Returns true if the given ts.Node is a comment\n * @param node the TypeScript node\n * @returns is comment\n */\nfunction isComment(node) {\n  return node.kind === SyntaxKind.SingleLineCommentTrivia || node.kind === SyntaxKind.MultiLineCommentTrivia;\n}\nexports.isComment = isComment;\n/**\n * Returns true if the given ts.Node is a JSDoc comment\n * @param node the TypeScript node\n * @returns is JSDoc comment\n */\nfunction isJSDocComment(node) {\n  return node.kind === SyntaxKind.JSDocComment;\n}\nexports.isJSDocComment = isJSDocComment;\n/**\n * Returns the binary expression type of the given ts.Token\n * @param operator the operator token\n * @returns the binary expression type\n */\nfunction getBinaryExpressionType(operator) {\n  if (isAssignmentOperator(operator)) {\n    return ts_estree_1.AST_NODE_TYPES.AssignmentExpression;\n  } else if (isLogicalOperator(operator)) {\n    return ts_estree_1.AST_NODE_TYPES.LogicalExpression;\n  }\n  return ts_estree_1.AST_NODE_TYPES.BinaryExpression;\n}\nexports.getBinaryExpressionType = getBinaryExpressionType;\n/**\n * Returns line and column data for the given positions,\n * @param pos position to check\n * @param ast the AST object\n * @returns line and column\n */\nfunction getLineAndCharacterFor(pos, ast) {\n  const loc = ast.getLineAndCharacterOfPosition(pos);\n  return {\n    line: loc.line + 1,\n    column: loc.character\n  };\n}\nexports.getLineAndCharacterFor = getLineAndCharacterFor;\n/**\n * Returns line and column data for the given start and end positions,\n * for the given AST\n * @param start start data\n * @param end   end data\n * @param ast   the AST object\n * @returns the loc data\n */\nfunction getLocFor(start, end, ast) {\n  return {\n    start: getLineAndCharacterFor(start, ast),\n    end: getLineAndCharacterFor(end, ast)\n  };\n}\nexports.getLocFor = getLocFor;\n/**\n * Check whatever node can contain directive\n * @param node\n * @returns returns true if node can contain directive\n */\nfunction canContainDirective(node) {\n  if (node.kind === ts.SyntaxKind.Block) {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.Constructor:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n        return true;\n      default:\n        return false;\n    }\n  }\n  return true;\n}\nexports.canContainDirective = canContainDirective;\n/**\n * Returns range for the given ts.Node\n * @param node the ts.Node or ts.Token\n * @param ast the AST object\n * @returns the range data\n */\nfunction getRange(node, ast) {\n  return [node.getStart(ast), node.getEnd()];\n}\nexports.getRange = getRange;\n/**\n * Returns true if a given ts.Node is a token\n * @param node the ts.Node\n * @returns is a token\n */\nfunction isToken(node) {\n  return node.kind >= SyntaxKind.FirstToken && node.kind <= SyntaxKind.LastToken;\n}\nexports.isToken = isToken;\n/**\n * Returns true if a given ts.Node is a JSX token\n * @param node ts.Node to be checked\n * @returns is a JSX token\n */\nfunction isJSXToken(node) {\n  return node.kind >= SyntaxKind.JsxElement && node.kind <= SyntaxKind.JsxAttribute;\n}\nexports.isJSXToken = isJSXToken;\n/**\n * Returns the declaration kind of the given ts.Node\n * @param node TypeScript AST node\n * @returns declaration kind\n */\nfunction getDeclarationKind(node) {\n  if (node.flags & ts.NodeFlags.Let) {\n    return 'let';\n  }\n  if (node.flags & ts.NodeFlags.Const) {\n    return 'const';\n  }\n  return 'var';\n}\nexports.getDeclarationKind = getDeclarationKind;\n/**\n * Gets a ts.Node's accessibility level\n * @param node The ts.Node\n * @returns accessibility \"public\", \"protected\", \"private\", or null\n */\nfunction getTSNodeAccessibility(node) {\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  if (modifiers == null) {\n    return null;\n  }\n  for (const modifier of modifiers) {\n    switch (modifier.kind) {\n      case SyntaxKind.PublicKeyword:\n        return 'public';\n      case SyntaxKind.ProtectedKeyword:\n        return 'protected';\n      case SyntaxKind.PrivateKeyword:\n        return 'private';\n      default:\n        break;\n    }\n  }\n  return null;\n}\nexports.getTSNodeAccessibility = getTSNodeAccessibility;\n/**\n * Finds the next token based on the previous one and its parent\n * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren\n * @param previousToken The previous TSToken\n * @param parent The parent TSNode\n * @param ast The TS AST\n * @returns the next TSToken\n */\nfunction findNextToken(previousToken, parent, ast) {\n  return find(parent);\n  function find(n) {\n    if (ts.isToken(n) && n.pos === previousToken.end) {\n      // this is token that starts at the end of previous token - return it\n      return n;\n    }\n    return firstDefined(n.getChildren(ast), child => {\n      const shouldDiveInChildNode =\n      // previous token is enclosed somewhere in the child\n      child.pos <= previousToken.pos && child.end > previousToken.end ||\n      // previous token ends exactly at the beginning of child\n      child.pos === previousToken.end;\n      return shouldDiveInChildNode && nodeHasTokens(child, ast) ? find(child) : undefined;\n    });\n  }\n}\nexports.findNextToken = findNextToken;\n/**\n * Find the first matching ancestor based on the given predicate function.\n * @param node The current ts.Node\n * @param predicate The predicate function to apply to each checked ancestor\n * @returns a matching parent ts.Node\n */\nfunction findFirstMatchingAncestor(node, predicate) {\n  while (node) {\n    if (predicate(node)) {\n      return node;\n    }\n    node = node.parent;\n  }\n  return undefined;\n}\nexports.findFirstMatchingAncestor = findFirstMatchingAncestor;\n/**\n * Returns true if a given ts.Node has a JSX token within its hierarchy\n * @param node ts.Node to be checked\n * @returns has JSX ancestor\n */\nfunction hasJSXAncestor(node) {\n  return !!findFirstMatchingAncestor(node, isJSXToken);\n}\nexports.hasJSXAncestor = hasJSXAncestor;\n/**\n * Unescape the text content of string literals, e.g. &amp; -> &\n * @param text The escaped string literal text.\n * @returns The unescaped string literal text.\n */\nfunction unescapeStringLiteralText(text) {\n  return text.replace(/&(?:#\\d+|#x[\\da-fA-F]+|[0-9a-zA-Z]+);/g, entity => {\n    const item = entity.slice(1, -1);\n    if (item[0] === '#') {\n      const codePoint = item[1] === 'x' ? parseInt(item.slice(2), 16) : parseInt(item.slice(1), 10);\n      return codePoint > 0x10ffff // RangeError: Invalid code point\n      ? entity : String.fromCodePoint(codePoint);\n    }\n    return xhtml_entities_1.xhtmlEntities[item] || entity;\n  });\n}\nexports.unescapeStringLiteralText = unescapeStringLiteralText;\n/**\n * Returns true if a given ts.Node is a computed property\n * @param node ts.Node to be checked\n * @returns is Computed Property\n */\nfunction isComputedProperty(node) {\n  return node.kind === SyntaxKind.ComputedPropertyName;\n}\nexports.isComputedProperty = isComputedProperty;\n/**\n * Returns true if a given ts.Node is optional (has QuestionToken)\n * @param node ts.Node to be checked\n * @returns is Optional\n */\nfunction isOptional(node) {\n  return node.questionToken ? node.questionToken.kind === SyntaxKind.QuestionToken : false;\n}\nexports.isOptional = isOptional;\n/**\n * Returns true if the node is an optional chain node\n */\nfunction isChainExpression(node) {\n  return node.type === ts_estree_1.AST_NODE_TYPES.ChainExpression;\n}\nexports.isChainExpression = isChainExpression;\n/**\n * Returns true of the child of property access expression is an optional chain\n */\nfunction isChildUnwrappableOptionalChain(node, child) {\n  return isChainExpression(child) &&\n  // (x?.y).z is semantically different, and as such .z is no longer optional\n  node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression;\n}\nexports.isChildUnwrappableOptionalChain = isChildUnwrappableOptionalChain;\n/**\n * Returns the type of a given ts.Token\n * @param token the ts.Token\n * @returns the token type\n */\nfunction getTokenType(token) {\n  let keywordKind;\n  if (isAtLeast50 && token.kind === SyntaxKind.Identifier) {\n    keywordKind = ts.identifierToKeywordKind(token);\n  } else if ('originalKeywordKind' in token) {\n    // eslint-disable-next-line deprecation/deprecation -- intentional fallback for older TS versions\n    keywordKind = token.originalKeywordKind;\n  }\n  if (keywordKind) {\n    if (keywordKind === SyntaxKind.NullKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Null;\n    } else if (keywordKind >= SyntaxKind.FirstFutureReservedWord && keywordKind <= SyntaxKind.LastKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n    }\n    return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n  }\n  if (token.kind >= SyntaxKind.FirstKeyword && token.kind <= SyntaxKind.LastFutureReservedWord) {\n    if (token.kind === SyntaxKind.FalseKeyword || token.kind === SyntaxKind.TrueKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Boolean;\n    }\n    return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n  }\n  if (token.kind >= SyntaxKind.FirstPunctuation && token.kind <= SyntaxKind.LastPunctuation) {\n    return ts_estree_1.AST_TOKEN_TYPES.Punctuator;\n  }\n  if (token.kind >= SyntaxKind.NoSubstitutionTemplateLiteral && token.kind <= SyntaxKind.TemplateTail) {\n    return ts_estree_1.AST_TOKEN_TYPES.Template;\n  }\n  switch (token.kind) {\n    case SyntaxKind.NumericLiteral:\n      return ts_estree_1.AST_TOKEN_TYPES.Numeric;\n    case SyntaxKind.JsxText:\n      return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n    case SyntaxKind.StringLiteral:\n      // A TypeScript-StringLiteral token with a TypeScript-JsxAttribute or TypeScript-JsxElement parent,\n      // must actually be an ESTree-JSXText token\n      if (token.parent && (token.parent.kind === SyntaxKind.JsxAttribute || token.parent.kind === SyntaxKind.JsxElement)) {\n        return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n      }\n      return ts_estree_1.AST_TOKEN_TYPES.String;\n    case SyntaxKind.RegularExpressionLiteral:\n      return ts_estree_1.AST_TOKEN_TYPES.RegularExpression;\n    case SyntaxKind.Identifier:\n    case SyntaxKind.ConstructorKeyword:\n    case SyntaxKind.GetKeyword:\n    case SyntaxKind.SetKeyword:\n    // intentional fallthrough\n    default:\n  }\n  // Some JSX tokens have to be determined based on their parent\n  if (token.parent && token.kind === SyntaxKind.Identifier) {\n    if (isJSXToken(token.parent)) {\n      return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n    }\n    if (token.parent.kind === SyntaxKind.PropertyAccessExpression && hasJSXAncestor(token)) {\n      return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n    }\n  }\n  return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n}\nexports.getTokenType = getTokenType;\n/**\n * Extends and formats a given ts.Token, for a given AST\n * @param token the ts.Token\n * @param ast   the AST object\n * @returns the converted Token\n */\nfunction convertToken(token, ast) {\n  const start = token.kind === SyntaxKind.JsxText ? token.getFullStart() : token.getStart(ast);\n  const end = token.getEnd();\n  const value = ast.text.slice(start, end);\n  const tokenType = getTokenType(token);\n  if (tokenType === ts_estree_1.AST_TOKEN_TYPES.RegularExpression) {\n    return {\n      type: tokenType,\n      value,\n      range: [start, end],\n      loc: getLocFor(start, end, ast),\n      regex: {\n        pattern: value.slice(1, value.lastIndexOf('/')),\n        flags: value.slice(value.lastIndexOf('/') + 1)\n      }\n    };\n  } else {\n    // @ts-expect-error TS is complaining about `value` not being the correct\n    // type but it is\n    return {\n      type: tokenType,\n      value,\n      range: [start, end],\n      loc: getLocFor(start, end, ast)\n    };\n  }\n}\nexports.convertToken = convertToken;\n/**\n * Converts all tokens for the given AST\n * @param ast the AST object\n * @returns the converted Tokens\n */\nfunction convertTokens(ast) {\n  const result = [];\n  /**\n   * @param node the ts.Node\n   */\n  function walk(node) {\n    // TypeScript generates tokens for types in JSDoc blocks. Comment tokens\n    // and their children should not be walked or added to the resulting tokens list.\n    if (isComment(node) || isJSDocComment(node)) {\n      return;\n    }\n    if (isToken(node) && node.kind !== SyntaxKind.EndOfFileToken) {\n      const converted = convertToken(node, ast);\n      if (converted) {\n        result.push(converted);\n      }\n    } else {\n      node.getChildren(ast).forEach(walk);\n    }\n  }\n  walk(ast);\n  return result;\n}\nexports.convertTokens = convertTokens;\nclass TSError extends Error {\n  constructor(message, fileName, index, lineNumber, column) {\n    super(message);\n    this.fileName = fileName;\n    this.index = index;\n    this.lineNumber = lineNumber;\n    this.column = column;\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n  }\n}\nexports.TSError = TSError;\n/**\n * @param ast     the AST object\n * @param start   the index at which the error starts\n * @param message the error message\n * @returns converted error object\n */\nfunction createError(ast, start, message) {\n  const loc = ast.getLineAndCharacterOfPosition(start);\n  return new TSError(message, ast.fileName, start, loc.line + 1, loc.character);\n}\nexports.createError = createError;\n/**\n * @param n the TSNode\n * @param ast the TS AST\n */\nfunction nodeHasTokens(n, ast) {\n  // If we have a token or node that has a non-zero width, it must have tokens.\n  // Note: getWidth() does not take trivia into account.\n  return n.kind === SyntaxKind.EndOfFileToken ? !!n.jsDoc : n.getWidth(ast) !== 0;\n}\nexports.nodeHasTokens = nodeHasTokens;\n/**\n * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).\n * @template T\n * @template U\n * @param array\n * @param callback\n */\nfunction firstDefined(array, callback) {\n  if (array === undefined) {\n    return undefined;\n  }\n  for (let i = 0; i < array.length; i++) {\n    const result = callback(array[i], i);\n    if (result !== undefined) {\n      return result;\n    }\n  }\n  return undefined;\n}\nexports.firstDefined = firstDefined;\nfunction identifierIsThisKeyword(id) {\n  return (\n    // eslint-disable-next-line deprecation/deprecation -- intentional for older TS versions\n    (isAtLeast50 ? ts.identifierToKeywordKind(id) : id.originalKeywordKind) === SyntaxKind.ThisKeyword\n  );\n}\nexports.identifierIsThisKeyword = identifierIsThisKeyword;\nfunction isThisIdentifier(node) {\n  return !!node && node.kind === SyntaxKind.Identifier && identifierIsThisKeyword(node);\n}\nexports.isThisIdentifier = isThisIdentifier;\nfunction isThisInTypeQuery(node) {\n  if (!isThisIdentifier(node)) {\n    return false;\n  }\n  while (ts.isQualifiedName(node.parent) && node.parent.left === node) {\n    node = node.parent;\n  }\n  return node.parent.kind === SyntaxKind.TypeQuery;\n}\nexports.isThisInTypeQuery = isThisInTypeQuery;","map":{"version":3,"mappings":"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","names":["isAtLeast50","version_check_1","SyntaxKind","ts","LOGICAL_OPERATORS","BarBarToken","AmpersandAmpersandToken","QuestionQuestionToken","isAssignmentOperator","operator","kind","FirstAssignment","LastAssignment","exports","isLogicalOperator","includes","getTextForTokenKind","tokenToString","isESTreeClassMember","node","SemicolonClassElement","hasModifier","modifierKind","modifiers","some","modifier","getLastModifier","length","isComma","token","CommaToken","isComment","SingleLineCommentTrivia","MultiLineCommentTrivia","isJSDocComment","JSDocComment","getBinaryExpressionType","ts_estree_1","AssignmentExpression","LogicalExpression","BinaryExpression","getLineAndCharacterFor","pos","ast","loc","getLineAndCharacterOfPosition","line","column","character","getLocFor","start","end","canContainDirective","Block","parent","Constructor","GetAccessor","SetAccessor","ArrowFunction","FunctionExpression","FunctionDeclaration","MethodDeclaration","getRange","getStart","getEnd","isToken","FirstToken","LastToken","isJSXToken","JsxElement","JsxAttribute","getDeclarationKind","flags","NodeFlags","Let","Const","getTSNodeAccessibility","PublicKeyword","ProtectedKeyword","PrivateKeyword","findNextToken","previousToken","find","n","firstDefined","getChildren","child","shouldDiveInChildNode","nodeHasTokens","undefined","findFirstMatchingAncestor","predicate","hasJSXAncestor","unescapeStringLiteralText","text","replace","entity","item","slice","codePoint","parseInt","String","fromCodePoint","xhtml_entities_1","isComputedProperty","ComputedPropertyName","isOptional","questionToken","QuestionToken","isChainExpression","type","ChainExpression","isChildUnwrappableOptionalChain","expression","ParenthesizedExpression","getTokenType","keywordKind","Identifier","identifierToKeywordKind","originalKeywordKind","NullKeyword","Null","FirstFutureReservedWord","LastKeyword","Keyword","FirstKeyword","LastFutureReservedWord","FalseKeyword","TrueKeyword","Boolean","FirstPunctuation","LastPunctuation","Punctuator","NoSubstitutionTemplateLiteral","TemplateTail","Template","NumericLiteral","Numeric","JsxText","JSXText","StringLiteral","RegularExpressionLiteral","RegularExpression","ConstructorKeyword","GetKeyword","SetKeyword","JSXIdentifier","PropertyAccessExpression","convertToken","getFullStart","value","tokenType","range","regex","pattern","lastIndexOf","convertTokens","result","walk","EndOfFileToken","converted","push","forEach","TSError","Error","constructor","message","fileName","index","lineNumber","Object","defineProperty","new","target","name","enumerable","configurable","createError","jsDoc","getWidth","array","callback","i","identifierIsThisKeyword","id","ThisKeyword","isThisIdentifier","isThisInTypeQuery","isQualifiedName","left","TypeQuery"],"sources":["../src/node-utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}