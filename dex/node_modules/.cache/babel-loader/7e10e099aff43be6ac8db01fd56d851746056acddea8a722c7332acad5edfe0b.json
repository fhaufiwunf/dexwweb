{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertComments = void 0;\nconst util_1 = require(\"tsutils/util/util\");\nconst ts = __importStar(require(\"typescript\"));\nconst node_utils_1 = require(\"./node-utils\");\nconst ts_estree_1 = require(\"./ts-estree\");\n/**\n * Convert all comments for the given AST.\n * @param ast the AST object\n * @param code the TypeScript code\n * @returns the converted ESTreeComment\n * @private\n */\nfunction convertComments(ast, code) {\n  const comments = [];\n  (0, util_1.forEachComment)(ast, (_, comment) => {\n    const type = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? ts_estree_1.AST_TOKEN_TYPES.Line : ts_estree_1.AST_TOKEN_TYPES.Block;\n    const range = [comment.pos, comment.end];\n    const loc = (0, node_utils_1.getLocFor)(range[0], range[1], ast);\n    // both comments start with 2 characters - /* or //\n    const textStart = range[0] + 2;\n    const textEnd = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ?\n    // single line comments end at the end\n    range[1] - textStart :\n    // multiline comments end 2 characters early\n    range[1] - textStart - 2;\n    comments.push({\n      type,\n      value: code.slice(textStart, textStart + textEnd),\n      range,\n      loc\n    });\n  }, ast);\n  return comments;\n}\nexports.convertComments = convertComments;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AAEA;AAEA;;;;;;;AAOA,SAAgBA,eAAeA,CAC7BC,GAAkB,EAClBC,IAAY;EAEZ,MAAMC,QAAQ,GAAuB,EAAE;EAEvC,yBAAc,EACZF,GAAG,EACH,CAACG,CAAC,EAAEC,OAAO,KAAI;IACb,MAAMC,IAAI,GACRD,OAAO,CAACE,IAAI,KAAKC,EAAE,CAACC,UAAU,CAACC,uBAAuB,GAClDC,2BAAe,CAACC,IAAI,GACpBD,2BAAe,CAACE,KAAK;IAC3B,MAAMC,KAAK,GAAmB,CAACT,OAAO,CAACU,GAAG,EAAEV,OAAO,CAACW,GAAG,CAAC;IACxD,MAAMC,GAAG,GAAG,0BAAS,EAACH,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEb,GAAG,CAAC;IAE9C;IACA,MAAMiB,SAAS,GAAGJ,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;IAC9B,MAAMK,OAAO,GACXd,OAAO,CAACE,IAAI,KAAKC,EAAE,CAACC,UAAU,CAACC,uBAAuB;IAClD;IACAI,KAAK,CAAC,CAAC,CAAC,GAAGI,SAAS;IACpB;IACAJ,KAAK,CAAC,CAAC,CAAC,GAAGI,SAAS,GAAG,CAAC;IAC9Bf,QAAQ,CAACiB,IAAI,CAAC;MACZd,IAAI;MACJe,KAAK,EAAEnB,IAAI,CAACoB,KAAK,CAACJ,SAAS,EAAEA,SAAS,GAAGC,OAAO,CAAC;MACjDL,KAAK;MACLG;KACD,CAAC;EACJ,CAAC,EACDhB,GAAG,CACJ;EAED,OAAOE,QAAQ;AACjB;AAnCAoB","names":["convertComments","ast","code","comments","_","comment","type","kind","ts","SyntaxKind","SingleLineCommentTrivia","ts_estree_1","Line","Block","range","pos","end","loc","textStart","textEnd","push","value","slice","exports"],"sources":["../src/convert-comments.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}