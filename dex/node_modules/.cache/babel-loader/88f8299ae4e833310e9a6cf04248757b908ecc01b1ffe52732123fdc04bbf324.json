{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWatchProgramsForProjects = exports.clearWatchCaches = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst ts = __importStar(require(\"typescript\"));\nconst shared_1 = require(\"./shared\");\nconst log = (0, debug_1.default)('typescript-eslint:typescript-estree:createWatchProgram');\n/**\n * Maps tsconfig paths to their corresponding file contents and resulting watches\n */\nconst knownWatchProgramMap = new Map();\n/**\n * Maps file/folder paths to their set of corresponding watch callbacks\n * There may be more than one per file/folder if a file/folder is shared between projects\n */\nconst fileWatchCallbackTrackingMap = new Map();\nconst folderWatchCallbackTrackingMap = new Map();\n/**\n * Stores the list of known files for each program\n */\nconst programFileListCache = new Map();\n/**\n * Caches the last modified time of the tsconfig files\n */\nconst tsconfigLastModifiedTimestampCache = new Map();\nconst parsedFilesSeenHash = new Map();\n/**\n * Clear all of the parser caches.\n * This should only be used in testing to ensure the parser is clean between tests.\n */\nfunction clearWatchCaches() {\n  knownWatchProgramMap.clear();\n  fileWatchCallbackTrackingMap.clear();\n  folderWatchCallbackTrackingMap.clear();\n  parsedFilesSeenHash.clear();\n  programFileListCache.clear();\n  tsconfigLastModifiedTimestampCache.clear();\n}\nexports.clearWatchCaches = clearWatchCaches;\nfunction saveWatchCallback(trackingMap) {\n  return (fileName, callback) => {\n    const normalizedFileName = (0, shared_1.getCanonicalFileName)(fileName);\n    const watchers = (() => {\n      let watchers = trackingMap.get(normalizedFileName);\n      if (!watchers) {\n        watchers = new Set();\n        trackingMap.set(normalizedFileName, watchers);\n      }\n      return watchers;\n    })();\n    watchers.add(callback);\n    return {\n      close: () => {\n        watchers.delete(callback);\n      }\n    };\n  };\n}\n/**\n * Holds information about the file currently being linted\n */\nconst currentLintOperationState = {\n  code: '',\n  filePath: ''\n};\n/**\n * Appropriately report issues found when reading a config file\n * @param diagnostic The diagnostic raised when creating a program\n */\nfunction diagnosticReporter(diagnostic) {\n  throw new Error(ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine));\n}\nfunction updateCachedFileList(tsconfigPath, program, parseSettings) {\n  const fileList = parseSettings.EXPERIMENTAL_useSourceOfProjectReferenceRedirect ? new Set(program.getSourceFiles().map(sf => (0, shared_1.getCanonicalFileName)(sf.fileName))) : new Set(program.getRootFileNames().map(f => (0, shared_1.getCanonicalFileName)(f)));\n  programFileListCache.set(tsconfigPath, fileList);\n  return fileList;\n}\n/**\n * Calculate project environments using options provided by consumer and paths from config\n * @param parseSettings Internal settings for parsing the file\n * @returns The programs corresponding to the supplied tsconfig paths\n */\nfunction getWatchProgramsForProjects(parseSettings) {\n  const filePath = (0, shared_1.getCanonicalFileName)(parseSettings.filePath);\n  const results = [];\n  // preserve reference to code and file being linted\n  currentLintOperationState.code = parseSettings.code;\n  currentLintOperationState.filePath = filePath;\n  // Update file version if necessary\n  const fileWatchCallbacks = fileWatchCallbackTrackingMap.get(filePath);\n  const codeHash = (0, shared_1.createHash)(parseSettings.code);\n  if (parsedFilesSeenHash.get(filePath) !== codeHash && fileWatchCallbacks && fileWatchCallbacks.size > 0) {\n    fileWatchCallbacks.forEach(cb => cb(filePath, ts.FileWatcherEventKind.Changed));\n  }\n  const currentProjectsFromSettings = new Set(parseSettings.projects);\n  /*\n   * before we go into the process of attempting to find and update every program\n   * see if we know of a program that contains this file\n   */\n  for (const [tsconfigPath, existingWatch] of knownWatchProgramMap.entries()) {\n    if (!currentProjectsFromSettings.has(tsconfigPath)) {\n      // the current parser run doesn't specify this tsconfig in parserOptions.project\n      // so we don't want to consider it for caching purposes.\n      //\n      // if we did consider it we might return a program for a project\n      // that wasn't specified in the current parser run (which is obv bad!).\n      continue;\n    }\n    let fileList = programFileListCache.get(tsconfigPath);\n    let updatedProgram = null;\n    if (!fileList) {\n      updatedProgram = existingWatch.getProgram().getProgram();\n      fileList = updateCachedFileList(tsconfigPath, updatedProgram, parseSettings);\n    }\n    if (fileList.has(filePath)) {\n      log('Found existing program for file. %s', filePath);\n      updatedProgram = updatedProgram !== null && updatedProgram !== void 0 ? updatedProgram : existingWatch.getProgram().getProgram();\n      // sets parent pointers in source files\n      updatedProgram.getTypeChecker();\n      return [updatedProgram];\n    }\n  }\n  log('File did not belong to any existing programs, moving to create/update. %s', filePath);\n  /*\n   * We don't know of a program that contains the file, this means that either:\n   * - the required program hasn't been created yet, or\n   * - the file is new/renamed, and the program hasn't been updated.\n   */\n  for (const tsconfigPath of parseSettings.projects) {\n    const existingWatch = knownWatchProgramMap.get(tsconfigPath);\n    if (existingWatch) {\n      const updatedProgram = maybeInvalidateProgram(existingWatch, filePath, tsconfigPath);\n      if (!updatedProgram) {\n        continue;\n      }\n      // sets parent pointers in source files\n      updatedProgram.getTypeChecker();\n      // cache and check the file list\n      const fileList = updateCachedFileList(tsconfigPath, updatedProgram, parseSettings);\n      if (fileList.has(filePath)) {\n        log('Found updated program for file. %s', filePath);\n        // we can return early because we know this program contains the file\n        return [updatedProgram];\n      }\n      results.push(updatedProgram);\n      continue;\n    }\n    const programWatch = createWatchProgram(tsconfigPath, parseSettings);\n    knownWatchProgramMap.set(tsconfigPath, programWatch);\n    const program = programWatch.getProgram().getProgram();\n    // sets parent pointers in source files\n    program.getTypeChecker();\n    // cache and check the file list\n    const fileList = updateCachedFileList(tsconfigPath, program, parseSettings);\n    if (fileList.has(filePath)) {\n      log('Found program for file. %s', filePath);\n      // we can return early because we know this program contains the file\n      return [program];\n    }\n    results.push(program);\n  }\n  return results;\n}\nexports.getWatchProgramsForProjects = getWatchProgramsForProjects;\nconst isRunningNoTimeoutFix = semver_1.default.satisfies(ts.version, '>=3.9.0-beta', {\n  includePrerelease: true\n});\nfunction createWatchProgram(tsconfigPath, parseSettings) {\n  log('Creating watch program for %s.', tsconfigPath);\n  // create compiler host\n  const watchCompilerHost = ts.createWatchCompilerHost(tsconfigPath, (0, shared_1.createDefaultCompilerOptionsFromExtra)(parseSettings), ts.sys, ts.createAbstractBuilder, diagnosticReporter, /*reportWatchStatus*/() => {});\n  if (parseSettings.moduleResolver) {\n    // eslint-disable-next-line deprecation/deprecation -- intentional for older TS versions\n    watchCompilerHost.resolveModuleNames = (0, shared_1.getModuleResolver)(parseSettings.moduleResolver).resolveModuleNames;\n  }\n  // ensure readFile reads the code being linted instead of the copy on disk\n  const oldReadFile = watchCompilerHost.readFile;\n  watchCompilerHost.readFile = (filePathIn, encoding) => {\n    const filePath = (0, shared_1.getCanonicalFileName)(filePathIn);\n    const fileContent = filePath === currentLintOperationState.filePath ? currentLintOperationState.code : oldReadFile(filePath, encoding);\n    if (fileContent !== undefined) {\n      parsedFilesSeenHash.set(filePath, (0, shared_1.createHash)(fileContent));\n    }\n    return fileContent;\n  };\n  // ensure process reports error on failure instead of exiting process immediately\n  watchCompilerHost.onUnRecoverableConfigFileDiagnostic = diagnosticReporter;\n  // ensure process doesn't emit programs\n  watchCompilerHost.afterProgramCreate = program => {\n    // report error if there are any errors in the config file\n    const configFileDiagnostics = program.getConfigFileParsingDiagnostics().filter(diag => diag.category === ts.DiagnosticCategory.Error && diag.code !== 18003);\n    if (configFileDiagnostics.length > 0) {\n      diagnosticReporter(configFileDiagnostics[0]);\n    }\n  };\n  /*\n   * From the CLI, the file watchers won't matter, as the files will be parsed once and then forgotten.\n   * When running from an IDE, these watchers will let us tell typescript about changes.\n   *\n   * ESLint IDE plugins will send us unfinished file content as the user types (before it's saved to disk).\n   * We use the file watchers to tell typescript about this latest file content.\n   *\n   * When files are created (or renamed), we won't know about them because we have no filesystem watchers attached.\n   * We use the folder watchers to tell typescript it needs to go and find new files in the project folders.\n   */\n  watchCompilerHost.watchFile = saveWatchCallback(fileWatchCallbackTrackingMap);\n  watchCompilerHost.watchDirectory = saveWatchCallback(folderWatchCallbackTrackingMap);\n  // allow files with custom extensions to be included in program (uses internal ts api)\n  const oldOnDirectoryStructureHostCreate = watchCompilerHost.onCachedDirectoryStructureHostCreate;\n  watchCompilerHost.onCachedDirectoryStructureHostCreate = host => {\n    const oldReadDirectory = host.readDirectory;\n    host.readDirectory = (path, extensions, exclude, include, depth) => oldReadDirectory(path, !extensions ? undefined : extensions.concat(parseSettings.extraFileExtensions), exclude, include, depth);\n    oldOnDirectoryStructureHostCreate(host);\n  };\n  // This works only on 3.9\n  watchCompilerHost.extraFileExtensions = parseSettings.extraFileExtensions.map(extension => ({\n    extension,\n    isMixedContent: true,\n    scriptKind: ts.ScriptKind.Deferred\n  }));\n  watchCompilerHost.trace = log;\n  /**\n   * TODO: this needs refinement and development, but we're allowing users to opt-in to this for now for testing and feedback.\n   * See https://github.com/typescript-eslint/typescript-eslint/issues/2094\n   */\n  watchCompilerHost.useSourceOfProjectReferenceRedirect = () => parseSettings.EXPERIMENTAL_useSourceOfProjectReferenceRedirect;\n  // Since we don't want to asynchronously update program we want to disable timeout methods\n  // So any changes in the program will be delayed and updated when getProgram is called on watch\n  let callback;\n  if (isRunningNoTimeoutFix) {\n    watchCompilerHost.setTimeout = undefined;\n    watchCompilerHost.clearTimeout = undefined;\n  } else {\n    log('Running without timeout fix');\n    // But because of https://github.com/microsoft/TypeScript/pull/37308 we cannot just set it to undefined\n    // instead save it and call before getProgram is called\n    watchCompilerHost.setTimeout = function (cb, _ms) {\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      callback = cb.bind( /*this*/undefined, ...args);\n      return callback;\n    };\n    watchCompilerHost.clearTimeout = () => {\n      callback = undefined;\n    };\n  }\n  const watch = ts.createWatchProgram(watchCompilerHost);\n  if (!isRunningNoTimeoutFix) {\n    const originalGetProgram = watch.getProgram;\n    watch.getProgram = () => {\n      if (callback) {\n        callback();\n      }\n      callback = undefined;\n      return originalGetProgram.call(watch);\n    };\n  }\n  return watch;\n}\nfunction hasTSConfigChanged(tsconfigPath) {\n  const stat = fs_1.default.statSync(tsconfigPath);\n  const lastModifiedAt = stat.mtimeMs;\n  const cachedLastModifiedAt = tsconfigLastModifiedTimestampCache.get(tsconfigPath);\n  tsconfigLastModifiedTimestampCache.set(tsconfigPath, lastModifiedAt);\n  if (cachedLastModifiedAt === undefined) {\n    return false;\n  }\n  return Math.abs(cachedLastModifiedAt - lastModifiedAt) > Number.EPSILON;\n}\nfunction maybeInvalidateProgram(existingWatch, filePath, tsconfigPath) {\n  /*\n   * By calling watchProgram.getProgram(), it will trigger a resync of the program based on\n   * whatever new file content we've given it from our input.\n   */\n  let updatedProgram = existingWatch.getProgram().getProgram();\n  // In case this change causes problems in larger real world codebases\n  // Provide an escape hatch so people don't _have_ to revert to an older version\n  if (process.env.TSESTREE_NO_INVALIDATION === 'true') {\n    return updatedProgram;\n  }\n  if (hasTSConfigChanged(tsconfigPath)) {\n    /*\n     * If the stat of the tsconfig has changed, that could mean the include/exclude/files lists has changed\n     * We need to make sure typescript knows this so it can update appropriately\n     */\n    log('tsconfig has changed - triggering program update. %s', tsconfigPath);\n    fileWatchCallbackTrackingMap.get(tsconfigPath).forEach(cb => cb(tsconfigPath, ts.FileWatcherEventKind.Changed));\n    // tsconfig change means that the file list more than likely changed, so clear the cache\n    programFileListCache.delete(tsconfigPath);\n  }\n  let sourceFile = updatedProgram.getSourceFile(filePath);\n  if (sourceFile) {\n    return updatedProgram;\n  }\n  /*\n   * Missing source file means our program's folder structure might be out of date.\n   * So we need to tell typescript it needs to update the correct folder.\n   */\n  log('File was not found in program - triggering folder update. %s', filePath);\n  // Find the correct directory callback by climbing the folder tree\n  const currentDir = (0, shared_1.canonicalDirname)(filePath);\n  let current = null;\n  let next = currentDir;\n  let hasCallback = false;\n  while (current !== next) {\n    current = next;\n    const folderWatchCallbacks = folderWatchCallbackTrackingMap.get(current);\n    if (folderWatchCallbacks) {\n      folderWatchCallbacks.forEach(cb => {\n        if (currentDir !== current) {\n          cb(currentDir, ts.FileWatcherEventKind.Changed);\n        }\n        cb(current, ts.FileWatcherEventKind.Changed);\n      });\n      hasCallback = true;\n    }\n    next = (0, shared_1.canonicalDirname)(current);\n  }\n  if (!hasCallback) {\n    /*\n     * No callback means the paths don't matchup - so no point returning any program\n     * this will signal to the caller to skip this program\n     */\n    log('No callback found for file, not part of this program. %s', filePath);\n    return null;\n  }\n  // directory update means that the file list more than likely changed, so clear the cache\n  programFileListCache.delete(tsconfigPath);\n  // force the immediate resync\n  updatedProgram = existingWatch.getProgram().getProgram();\n  sourceFile = updatedProgram.getSourceFile(filePath);\n  if (sourceFile) {\n    return updatedProgram;\n  }\n  /*\n   * At this point we're in one of two states:\n   * - The file isn't supposed to be in this program due to exclusions\n   * - The file is new, and was renamed from an old, included filename\n   *\n   * For the latter case, we need to tell typescript that the old filename is now deleted\n   */\n  log('File was still not found in program after directory update - checking file deletions. %s', filePath);\n  const rootFilenames = updatedProgram.getRootFileNames();\n  // use find because we only need to \"delete\" one file to cause typescript to do a full resync\n  const deletedFile = rootFilenames.find(file => !fs_1.default.existsSync(file));\n  if (!deletedFile) {\n    // There are no deleted files, so it must be the former case of the file not belonging to this program\n    return null;\n  }\n  const fileWatchCallbacks = fileWatchCallbackTrackingMap.get((0, shared_1.getCanonicalFileName)(deletedFile));\n  if (!fileWatchCallbacks) {\n    // shouldn't happen, but just in case\n    log('Could not find watch callbacks for root file. %s', deletedFile);\n    return updatedProgram;\n  }\n  log('Marking file as deleted. %s', deletedFile);\n  fileWatchCallbacks.forEach(cb => cb(deletedFile, ts.FileWatcherEventKind.Deleted));\n  // deleted files means that the file list _has_ changed, so clear the cache\n  programFileListCache.delete(tsconfigPath);\n  updatedProgram = existingWatch.getProgram().getProgram();\n  sourceFile = updatedProgram.getSourceFile(filePath);\n  if (sourceFile) {\n    return updatedProgram;\n  }\n  log('File was still not found in program after deletion check, assuming it is not part of this program. %s', filePath);\n  return null;\n}","map":{"version":3,"mappings":"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","names":["log","knownWatchProgramMap","Map","fileWatchCallbackTrackingMap","folderWatchCallbackTrackingMap","programFileListCache","tsconfigLastModifiedTimestampCache","parsedFilesSeenHash","clearWatchCaches","clear","exports","saveWatchCallback","trackingMap","fileName","callback","normalizedFileName","watchers","get","Set","set","add","close","delete","currentLintOperationState","code","filePath","diagnosticReporter","diagnostic","Error","ts","flattenDiagnosticMessageText","messageText","sys","newLine","updateCachedFileList","tsconfigPath","program","parseSettings","fileList","EXPERIMENTAL_useSourceOfProjectReferenceRedirect","getSourceFiles","map","sf","getRootFileNames","f","getWatchProgramsForProjects","results","fileWatchCallbacks","codeHash","size","forEach","cb","FileWatcherEventKind","Changed","currentProjectsFromSettings","projects","existingWatch","entries","has","updatedProgram","getProgram","getTypeChecker","maybeInvalidateProgram","push","programWatch","createWatchProgram","isRunningNoTimeoutFix","semver_1","satisfies","version","includePrerelease","watchCompilerHost","createWatchCompilerHost","createAbstractBuilder","moduleResolver","resolveModuleNames","oldReadFile","readFile","filePathIn","encoding","fileContent","undefined","onUnRecoverableConfigFileDiagnostic","afterProgramCreate","configFileDiagnostics","getConfigFileParsingDiagnostics","filter","diag","category","DiagnosticCategory","length","watchFile","watchDirectory","oldOnDirectoryStructureHostCreate","onCachedDirectoryStructureHostCreate","host","oldReadDirectory","readDirectory","path","extensions","exclude","include","depth","concat","extraFileExtensions","extension","isMixedContent","scriptKind","ScriptKind","Deferred","trace","useSourceOfProjectReferenceRedirect","setTimeout","clearTimeout","_ms","args","bind","watch","originalGetProgram","call","hasTSConfigChanged","stat","fs_1","statSync","lastModifiedAt","mtimeMs","cachedLastModifiedAt","Math","abs","Number","EPSILON","process","env","TSESTREE_NO_INVALIDATION","sourceFile","getSourceFile","currentDir","current","next","hasCallback","folderWatchCallbacks","rootFilenames","deletedFile","find","file","existsSync","Deleted"],"sources":["../../src/create-program/getWatchProgramsForProjects.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}