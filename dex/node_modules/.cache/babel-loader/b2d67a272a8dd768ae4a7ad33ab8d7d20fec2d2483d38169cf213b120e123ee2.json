{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ScopeBase_declaredVariables, _ScopeBase_dynamic, _ScopeBase_staticCloseRef, _ScopeBase_dynamicCloseRef, _ScopeBase_globalCloseRef;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScopeBase = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst assert_1 = require(\"../assert\");\nconst definition_1 = require(\"../definition\");\nconst ID_1 = require(\"../ID\");\nconst Reference_1 = require(\"../referencer/Reference\");\nconst variable_1 = require(\"../variable\");\nconst ScopeType_1 = require(\"./ScopeType\");\n/**\n * Test if scope is strict\n */\nfunction isStrictScope(scope, block, isMethodDefinition) {\n  var _a;\n  let body;\n  // When upper scope is exists and strict, inner scope is also strict.\n  if ((_a = scope.upper) === null || _a === void 0 ? void 0 : _a.isStrict) {\n    return true;\n  }\n  if (isMethodDefinition) {\n    return true;\n  }\n  if (scope.type === ScopeType_1.ScopeType.class || scope.type === ScopeType_1.ScopeType.conditionalType || scope.type === ScopeType_1.ScopeType.functionType || scope.type === ScopeType_1.ScopeType.mappedType || scope.type === ScopeType_1.ScopeType.module || scope.type === ScopeType_1.ScopeType.tsEnum || scope.type === ScopeType_1.ScopeType.tsModule || scope.type === ScopeType_1.ScopeType.type) {\n    return true;\n  }\n  if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) {\n    return false;\n  }\n  if (scope.type === ScopeType_1.ScopeType.function) {\n    const functionBody = block;\n    switch (functionBody.type) {\n      case types_1.AST_NODE_TYPES.ArrowFunctionExpression:\n        if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {\n          return false;\n        }\n        body = functionBody.body;\n        break;\n      case types_1.AST_NODE_TYPES.Program:\n        body = functionBody;\n        break;\n      default:\n        body = functionBody.body;\n    }\n    if (!body) {\n      return false;\n    }\n  } else if (scope.type === ScopeType_1.ScopeType.global) {\n    body = block;\n  } else {\n    return false;\n  }\n  // Search 'use strict' directive.\n  for (const stmt of body.body) {\n    if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {\n      break;\n    }\n    if (stmt.directive === 'use strict') {\n      return true;\n    }\n    const expr = stmt.expression;\n    if (expr.type !== types_1.AST_NODE_TYPES.Literal) {\n      break;\n    }\n    if (expr.raw === '\"use strict\"' || expr.raw === \"'use strict'\") {\n      return true;\n    }\n    if (expr.value === 'use strict') {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Register scope\n */\nfunction registerScope(scopeManager, scope) {\n  scopeManager.scopes.push(scope);\n  const scopes = scopeManager.nodeToScope.get(scope.block);\n  if (scopes) {\n    scopes.push(scope);\n  } else {\n    scopeManager.nodeToScope.set(scope.block, [scope]);\n  }\n}\nconst generator = (0, ID_1.createIdGenerator)();\nconst VARIABLE_SCOPE_TYPES = new Set([ScopeType_1.ScopeType.classFieldInitializer, ScopeType_1.ScopeType.classStaticBlock, ScopeType_1.ScopeType.function, ScopeType_1.ScopeType.global, ScopeType_1.ScopeType.module, ScopeType_1.ScopeType.tsModule]);\nclass ScopeBase {\n  constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n    /**\n     * A unique ID for this instance - primarily used to help debugging and testing\n     */\n    this.$id = generator();\n    /**\n     * The array of child scopes. This does not include grandchild scopes.\n     * @public\n     */\n    this.childScopes = [];\n    /**\n     * A map of the variables for each node in this scope.\n     * This is map is a pointer to the one in the parent ScopeManager instance\n     */\n    _ScopeBase_declaredVariables.set(this, void 0);\n    /**\n     * Generally, through the lexical scoping of JS you can always know which variable an identifier in the source code\n     * refers to. There are a few exceptions to this rule. With `global` and `with` scopes you can only decide at runtime\n     * which variable a reference refers to.\n     * All those scopes are considered \"dynamic\".\n     */\n    _ScopeBase_dynamic.set(this, void 0);\n    /**\n     * Whether this scope is created by a FunctionExpression.\n     * @public\n     */\n    this.functionExpressionScope = false;\n    /**\n     * List of {@link Reference}s that are left to be resolved (i.e. which\n     * need to be linked to the variable they refer to).\n     */\n    this.leftToResolve = [];\n    /**\n     * Any variable {@link Reference} found in this scope.\n     * This includes occurrences of local variables as well as variables from parent scopes (including the global scope).\n     * For local variables this also includes defining occurrences (like in a 'var' statement).\n     * In a 'function' scope this does not include the occurrences of the formal parameter in the parameter list.\n     * @public\n     */\n    this.references = [];\n    /**\n     * The map from variable names to variable objects.\n     * @public\n     */\n    this.set = new Map();\n    /**\n     * The {@link Reference}s that are not resolved with this scope.\n     * @public\n     */\n    this.through = [];\n    /**\n     * The scoped {@link Variable}s of this scope.\n     * In the case of a 'function' scope this includes the automatic argument `arguments` as its first element, as well\n     * as all further formal arguments.\n     * This does not include variables which are defined in child scopes.\n     * @public\n     */\n    this.variables = [];\n    _ScopeBase_staticCloseRef.set(this, ref => {\n      const resolve = () => {\n        const name = ref.identifier.name;\n        const variable = this.set.get(name);\n        if (!variable) {\n          return false;\n        }\n        if (!this.isValidResolution(ref, variable)) {\n          return false;\n        }\n        // make sure we don't match a type reference to a value variable\n        const isValidTypeReference = ref.isTypeReference && variable.isTypeVariable;\n        const isValidValueReference = ref.isValueReference && variable.isValueVariable;\n        if (!isValidTypeReference && !isValidValueReference) {\n          return false;\n        }\n        variable.references.push(ref);\n        ref.resolved = variable;\n        return true;\n      };\n      if (!resolve()) {\n        this.delegateToUpperScope(ref);\n      }\n    });\n    _ScopeBase_dynamicCloseRef.set(this, ref => {\n      // notify all names are through to global\n      let current = this;\n      do {\n        current.through.push(ref);\n        current = current.upper;\n      } while (current);\n    });\n    _ScopeBase_globalCloseRef.set(this, (ref, scopeManager) => {\n      // let/const/class declarations should be resolved statically.\n      // others should be resolved dynamically.\n      if (this.shouldStaticallyCloseForGlobal(ref, scopeManager)) {\n        __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, \"f\").call(this, ref);\n      } else {\n        __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, \"f\").call(this, ref);\n      }\n    });\n    const upperScopeAsScopeBase = upperScope;\n    this.type = type;\n    __classPrivateFieldSet(this, _ScopeBase_dynamic, this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with, \"f\");\n    this.block = block;\n    this.variableScope = this.isVariableScope() ? this : upperScopeAsScopeBase.variableScope;\n    this.upper = upperScope;\n    /**\n     * Whether 'use strict' is in effect in this scope.\n     * @member {boolean} Scope#isStrict\n     */\n    this.isStrict = isStrictScope(this, block, isMethodDefinition);\n    if (upperScopeAsScopeBase) {\n      // this is guaranteed to be correct at runtime\n      upperScopeAsScopeBase.childScopes.push(this);\n    }\n    __classPrivateFieldSet(this, _ScopeBase_declaredVariables, scopeManager.declaredVariables, \"f\");\n    registerScope(scopeManager, this);\n  }\n  isVariableScope() {\n    return VARIABLE_SCOPE_TYPES.has(this.type);\n  }\n  shouldStaticallyClose() {\n    return !__classPrivateFieldGet(this, _ScopeBase_dynamic, \"f\");\n  }\n  shouldStaticallyCloseForGlobal(ref, scopeManager) {\n    // On global scope, let/const/class declarations should be resolved statically.\n    const name = ref.identifier.name;\n    const variable = this.set.get(name);\n    if (!variable) {\n      return false;\n    }\n    // variable exists on the scope\n    // in module mode, we can statically resolve everything, regardless of its decl type\n    if (scopeManager.isModule()) {\n      return true;\n    }\n    // in script mode, only certain cases should be statically resolved\n    // Example:\n    // a `var` decl is ignored by the runtime if it clashes with a global name\n    // this means that we should not resolve the reference to the variable\n    const defs = variable.defs;\n    return defs.length > 0 && defs.every(def => {\n      var _a;\n      if (def.type === definition_1.DefinitionType.Variable && ((_a = def.parent) === null || _a === void 0 ? void 0 : _a.type) === types_1.AST_NODE_TYPES.VariableDeclaration && def.parent.kind === 'var') {\n        return false;\n      }\n      return true;\n    });\n  }\n  close(scopeManager) {\n    let closeRef;\n    if (this.shouldStaticallyClose()) {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, \"f\");\n    } else if (this.type !== 'global') {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, \"f\");\n    } else {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_globalCloseRef, \"f\");\n    }\n    // Try Resolving all references in this scope.\n    (0, assert_1.assert)(this.leftToResolve);\n    this.leftToResolve.forEach(ref => closeRef(ref, scopeManager));\n    this.leftToResolve = null;\n    return this.upper;\n  }\n  /**\n   * To override by function scopes.\n   * References in default parameters isn't resolved to variables which are in their function body.\n   */\n  isValidResolution(_ref, _variable) {\n    return true;\n  }\n  delegateToUpperScope(ref) {\n    const upper = this.upper;\n    if (upper === null || upper === void 0 ? void 0 : upper.leftToResolve) {\n      upper.leftToResolve.push(ref);\n    }\n    this.through.push(ref);\n  }\n  addDeclaredVariablesOfNode(variable, node) {\n    if (node == null) {\n      return;\n    }\n    let variables = __classPrivateFieldGet(this, _ScopeBase_declaredVariables, \"f\").get(node);\n    if (variables == null) {\n      variables = [];\n      __classPrivateFieldGet(this, _ScopeBase_declaredVariables, \"f\").set(node, variables);\n    }\n    if (!variables.includes(variable)) {\n      variables.push(variable);\n    }\n  }\n  defineVariable(nameOrVariable, set, variables, node, def) {\n    const name = typeof nameOrVariable === 'string' ? nameOrVariable : nameOrVariable.name;\n    let variable = set.get(name);\n    if (!variable) {\n      variable = typeof nameOrVariable === 'string' ? new variable_1.Variable(name, this) : nameOrVariable;\n      set.set(name, variable);\n      variables.push(variable);\n    }\n    if (def) {\n      variable.defs.push(def);\n      this.addDeclaredVariablesOfNode(variable, def.node);\n      this.addDeclaredVariablesOfNode(variable, def.parent);\n    }\n    if (node) {\n      variable.identifiers.push(node);\n    }\n  }\n  defineIdentifier(node, def) {\n    this.defineVariable(node.name, this.set, this.variables, node, def);\n  }\n  defineLiteralIdentifier(node, def) {\n    this.defineVariable(node.value, this.set, this.variables, null, def);\n  }\n  referenceValue(node) {\n    let assign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Reference_1.ReferenceFlag.Read;\n    let writeExpr = arguments.length > 2 ? arguments[2] : undefined;\n    let maybeImplicitGlobal = arguments.length > 3 ? arguments[3] : undefined;\n    let init = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var _a;\n    const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n  referenceType(node) {\n    var _a;\n    const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n  referenceDualValueType(node) {\n    var _a;\n    const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n}\nexports.ScopeBase = ScopeBase;\n_ScopeBase_declaredVariables = new WeakMap(), _ScopeBase_dynamic = new WeakMap(), _ScopeBase_staticCloseRef = new WeakMap(), _ScopeBase_dynamicCloseRef = new WeakMap(), _ScopeBase_globalCloseRef = new WeakMap();","map":{"version":3,"mappings":"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","names":["isStrictScope","scope","block","isMethodDefinition","body","upper","isStrict","type","ScopeType_1","class","conditionalType","functionType","mappedType","module","tsEnum","tsModule","switch","function","functionBody","types_1","ArrowFunctionExpression","BlockStatement","Program","global","stmt","ExpressionStatement","directive","expr","expression","Literal","raw","value","registerScope","scopeManager","scopes","push","nodeToScope","get","set","generator","VARIABLE_SCOPE_TYPES","Set","classFieldInitializer","classStaticBlock","ScopeBase","constructor","upperScope","_ScopeBase_declaredVariables","_ScopeBase_dynamic","Map","_ScopeBase_staticCloseRef","ref","resolve","name","identifier","variable","isValidResolution","isValidTypeReference","isTypeReference","isTypeVariable","isValidValueReference","isValueReference","isValueVariable","references","resolved","delegateToUpperScope","_ScopeBase_dynamicCloseRef","current","through","_ScopeBase_globalCloseRef","shouldStaticallyCloseForGlobal","__classPrivateFieldGet","upperScopeAsScopeBase","__classPrivateFieldSet","with","variableScope","isVariableScope","childScopes","declaredVariables","has","shouldStaticallyClose","isModule","defs","length","every","def","definition_1","Variable","parent","VariableDeclaration","kind","close","closeRef","leftToResolve","forEach","_ref","_variable","addDeclaredVariablesOfNode","node","variables","includes","defineVariable","nameOrVariable","variable_1","identifiers","defineIdentifier","defineLiteralIdentifier","referenceValue","assign","Reference_1","Read","writeExpr","maybeImplicitGlobal","init","Value","referenceType","Type","referenceDualValueType","exports"],"sources":["../../src/scope/ScopeBase.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}