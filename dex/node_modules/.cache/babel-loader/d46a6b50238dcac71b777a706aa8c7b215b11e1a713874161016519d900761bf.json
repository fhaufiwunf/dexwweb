{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Converter = exports.convertError = void 0;\n// There's lots of funny stuff due to the typing of ts.Node\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access */\nconst ts = __importStar(require(\"typescript\"));\nconst getModifiers_1 = require(\"./getModifiers\");\nconst node_utils_1 = require(\"./node-utils\");\nconst ts_estree_1 = require(\"./ts-estree\");\nconst version_check_1 = require(\"./version-check\");\nconst SyntaxKind = ts.SyntaxKind;\n/**\n * Extends and formats a given error object\n * @param error the error object\n * @returns converted error object\n */\nfunction convertError(error) {\n  return (0, node_utils_1.createError)(error.file, error.start, 'message' in error && error.message || error.messageText);\n}\nexports.convertError = convertError;\nclass Converter {\n  /**\n   * Converts a TypeScript node into an ESTree node\n   * @param ast the full TypeScript AST\n   * @param options additional options for the conversion\n   * @returns the converted ESTreeNode\n   */\n  constructor(ast, options) {\n    this.esTreeNodeToTSNodeMap = new WeakMap();\n    this.tsNodeToESTreeNodeMap = new WeakMap();\n    this.allowPattern = false;\n    this.inTypeMode = false;\n    this.ast = ast;\n    this.options = Object.assign({}, options);\n  }\n  getASTMaps() {\n    return {\n      esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,\n      tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap\n    };\n  }\n  convertProgram() {\n    return this.converter(this.ast);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param node the child ts.Node\n   * @param parent parentNode\n   * @param inTypeMode flag to determine if we are in typeMode\n   * @param allowPattern flag to determine if patterns are allowed\n   * @returns the converted ESTree node\n   */\n  converter(node, parent, inTypeMode, allowPattern) {\n    /**\n     * Exit early for null and undefined\n     */\n    if (!node) {\n      return null;\n    }\n    const typeMode = this.inTypeMode;\n    const pattern = this.allowPattern;\n    if (inTypeMode !== undefined) {\n      this.inTypeMode = inTypeMode;\n    }\n    if (allowPattern !== undefined) {\n      this.allowPattern = allowPattern;\n    }\n    const result = this.convertNode(node, parent !== null && parent !== void 0 ? parent : node.parent);\n    this.registerTSNodeInNodeMap(node, result);\n    this.inTypeMode = typeMode;\n    this.allowPattern = pattern;\n    return result;\n  }\n  /**\n   * Fixes the exports of the given ts.Node\n   * @param node the ts.Node\n   * @param result result\n   * @returns the ESTreeNode with fixed exports\n   */\n  fixExports(node, result) {\n    // check for exports\n    const modifiers = (0, getModifiers_1.getModifiers)(node);\n    if ((modifiers === null || modifiers === void 0 ? void 0 : modifiers[0].kind) === SyntaxKind.ExportKeyword) {\n      /**\n       * Make sure that original node is registered instead of export\n       */\n      this.registerTSNodeInNodeMap(node, result);\n      const exportKeyword = modifiers[0];\n      const nextModifier = modifiers[1];\n      const declarationIsDefault = nextModifier && nextModifier.kind === SyntaxKind.DefaultKeyword;\n      const varToken = declarationIsDefault ? (0, node_utils_1.findNextToken)(nextModifier, this.ast, this.ast) : (0, node_utils_1.findNextToken)(exportKeyword, this.ast, this.ast);\n      result.range[0] = varToken.getStart(this.ast);\n      result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n      if (declarationIsDefault) {\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n          declaration: result,\n          range: [exportKeyword.getStart(this.ast), result.range[1]],\n          exportKind: 'value'\n        });\n      } else {\n        const isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration || result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n        const isDeclare = 'declare' in result && result.declare === true;\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n          // @ts-expect-error - TODO, narrow the types here\n          declaration: result,\n          specifiers: [],\n          source: null,\n          exportKind: isType || isDeclare ? 'type' : 'value',\n          range: [exportKeyword.getStart(this.ast), result.range[1]],\n          assertions: []\n        });\n      }\n    }\n    return result;\n  }\n  /**\n   * Register specific TypeScript node into map with first ESTree node provided\n   */\n  registerTSNodeInNodeMap(node, result) {\n    if (result && this.options.shouldPreserveNodeMaps) {\n      if (!this.tsNodeToESTreeNodeMap.has(node)) {\n        this.tsNodeToESTreeNodeMap.set(node, result);\n      }\n    }\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertPattern(child, parent) {\n    return this.converter(child, parent, this.inTypeMode, true);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertChild(child, parent) {\n    return this.converter(child, parent, this.inTypeMode, false);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertType(child, parent) {\n    return this.converter(child, parent, true, false);\n  }\n  createNode(node, data) {\n    const result = data;\n    if (!result.range) {\n      result.range = (0, node_utils_1.getRange)(\n      // this is completely valid, but TS hates it\n      node, this.ast);\n    }\n    if (!result.loc) {\n      result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n    }\n    if (result && this.options.shouldPreserveNodeMaps) {\n      this.esTreeNodeToTSNodeMap.set(result, node);\n    }\n    return result;\n  }\n  convertBindingNameWithTypeAnnotation(name, tsType, parent) {\n    const id = this.convertPattern(name);\n    if (tsType) {\n      id.typeAnnotation = this.convertTypeAnnotation(tsType, parent);\n      this.fixParentLocation(id, id.typeAnnotation.range);\n    }\n    return id;\n  }\n  /**\n   * Converts a child into a type annotation. This creates an intermediary\n   * TypeAnnotation node to match what Flow does.\n   * @param child The TypeScript AST node to convert.\n   * @param parent parentNode\n   * @returns The type annotation node.\n   */\n  convertTypeAnnotation(child, parent) {\n    // in FunctionType and ConstructorType typeAnnotation has 2 characters `=>` and in other places is just colon\n    const offset = (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.FunctionType || (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.ConstructorType ? 2 : 1;\n    const annotationStartCol = child.getFullStart() - offset;\n    const loc = (0, node_utils_1.getLocFor)(annotationStartCol, child.end, this.ast);\n    return {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,\n      loc,\n      range: [annotationStartCol, child.end],\n      typeAnnotation: this.convertType(child)\n    };\n  }\n  /**\n   * Coverts body Nodes and add a directive field to StringLiterals\n   * @param nodes of ts.Node\n   * @param parent parentNode\n   * @returns Array of body statements\n   */\n  convertBodyExpressions(nodes, parent) {\n    let allowDirectives = (0, node_utils_1.canContainDirective)(parent);\n    return nodes.map(statement => {\n      const child = this.convertChild(statement);\n      if (allowDirectives) {\n        if ((child === null || child === void 0 ? void 0 : child.expression) && ts.isExpressionStatement(statement) && ts.isStringLiteral(statement.expression)) {\n          const raw = child.expression.raw;\n          child.directive = raw.slice(1, -1);\n          return child; // child can be null, but it's filtered below\n        } else {\n          allowDirectives = false;\n        }\n      }\n      return child; // child can be null, but it's filtered below\n    })\n    // filter out unknown nodes for now\n    .filter(statement => statement);\n  }\n  /**\n   * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node\n   * @param typeArguments ts.NodeArray typeArguments\n   * @param node parent used to create this node\n   * @returns TypeParameterInstantiation node\n   */\n  convertTypeArgumentsToTypeParameters(typeArguments, node) {\n    const greaterThanToken = (0, node_utils_1.findNextToken)(typeArguments, this.ast, this.ast);\n    return this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,\n      range: [typeArguments.pos - 1, greaterThanToken.end],\n      params: typeArguments.map(typeArgument => this.convertType(typeArgument))\n    });\n  }\n  /**\n   * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node\n   * @param typeParameters ts.Node typeParameters\n   * @returns TypeParameterDeclaration node\n   */\n  convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {\n    const greaterThanToken = (0, node_utils_1.findNextToken)(typeParameters, this.ast, this.ast);\n    return {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,\n      range: [typeParameters.pos - 1, greaterThanToken.end],\n      loc: (0, node_utils_1.getLocFor)(typeParameters.pos - 1, greaterThanToken.end, this.ast),\n      params: typeParameters.map(typeParameter => this.convertType(typeParameter))\n    };\n  }\n  /**\n   * Converts an array of ts.Node parameters into an array of ESTreeNode params\n   * @param parameters An array of ts.Node params to be converted\n   * @returns an array of converted ESTreeNode params\n   */\n  convertParameters(parameters) {\n    if (!(parameters === null || parameters === void 0 ? void 0 : parameters.length)) {\n      return [];\n    }\n    return parameters.map(param => {\n      const convertedParam = this.convertChild(param);\n      const decorators = (0, getModifiers_1.getDecorators)(param);\n      if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {\n        convertedParam.decorators = decorators.map(el => this.convertChild(el));\n      }\n      return convertedParam;\n    });\n  }\n  convertChainExpression(node, tsNode) {\n    const {\n      child,\n      isOptional\n    } = (() => {\n      if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n        return {\n          child: node.object,\n          isOptional: node.optional\n        };\n      }\n      if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n        return {\n          child: node.callee,\n          isOptional: node.optional\n        };\n      }\n      return {\n        child: node.expression,\n        isOptional: false\n      };\n    })();\n    const isChildUnwrappable = (0, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);\n    if (!isChildUnwrappable && !isOptional) {\n      return node;\n    }\n    if (isChildUnwrappable && (0, node_utils_1.isChainExpression)(child)) {\n      // unwrap the chain expression child\n      const newChild = child.expression;\n      if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n        node.object = newChild;\n      } else if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n        node.callee = newChild;\n      } else {\n        node.expression = newChild;\n      }\n    }\n    return this.createNode(tsNode, {\n      type: ts_estree_1.AST_NODE_TYPES.ChainExpression,\n      expression: node\n    });\n  }\n  /**\n   * For nodes that are copied directly from the TypeScript AST into\n   * ESTree mostly as-is. The only difference is the addition of a type\n   * property instead of a kind property. Recursively copies all children.\n   */\n  deeplyCopy(node) {\n    if (node.kind === ts.SyntaxKind.JSDocFunctionType) {\n      throw (0, node_utils_1.createError)(this.ast, node.pos, 'JSDoc types can only be used inside documentation comments.');\n    }\n    const customType = `TS${SyntaxKind[node.kind]}`;\n    /**\n     * If the \"errorOnUnknownASTType\" option is set to true, throw an error,\n     * otherwise fallback to just including the unknown type as-is.\n     */\n    if (this.options.errorOnUnknownASTType && !ts_estree_1.AST_NODE_TYPES[customType]) {\n      throw new Error(`Unknown AST_NODE_TYPE: \"${customType}\"`);\n    }\n    const result = this.createNode(node, {\n      type: customType\n    });\n    if ('type' in node) {\n      result.typeAnnotation = node.type && 'kind' in node.type && ts.isTypeNode(node.type) ? this.convertTypeAnnotation(node.type, node) : null;\n    }\n    if ('typeArguments' in node) {\n      result.typeParameters = node.typeArguments && 'pos' in node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null;\n    }\n    if ('typeParameters' in node) {\n      result.typeParameters = node.typeParameters && 'pos' in node.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters) : null;\n    }\n    const decorators = (0, getModifiers_1.getDecorators)(node);\n    if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {\n      result.decorators = decorators.map(el => this.convertChild(el));\n    }\n    // keys we never want to clone from the base typescript node as they\n    // introduce garbage into our AST\n    const KEYS_TO_NOT_COPY = new Set(['_children', 'decorators', 'end', 'flags', 'illegalDecorators', 'heritageClauses', 'locals', 'localSymbol', 'jsDoc', 'kind', 'modifierFlagsCache', 'modifiers', 'nextContainer', 'parent', 'pos', 'symbol', 'transformFlags', 'type', 'typeArguments', 'typeParameters']);\n    Object.entries(node).filter(_ref => {\n      let [key] = _ref;\n      return !KEYS_TO_NOT_COPY.has(key);\n    }).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      if (Array.isArray(value)) {\n        result[key] = value.map(el => this.convertChild(el));\n      } else if (value && typeof value === 'object' && value.kind) {\n        // need to check node[key].kind to ensure we don't try to convert a symbol\n        result[key] = this.convertChild(value);\n      } else {\n        result[key] = value;\n      }\n    });\n    return result;\n  }\n  convertJSXIdentifier(node) {\n    const result = this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n      name: node.getText()\n    });\n    this.registerTSNodeInNodeMap(node, result);\n    return result;\n  }\n  convertJSXNamespaceOrIdentifier(node) {\n    // TypeScript@5.1 added in ts.JsxNamespacedName directly\n    // We prefer using that if it's relevant for this node type\n    if (node.kind === ts.SyntaxKind.JsxNamespacedName) {\n      const result = this.createNode(node, {\n        type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n        namespace: this.createNode(node.namespace, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: node.namespace.text\n        }),\n        name: this.createNode(node.name, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: node.name.text\n        })\n      });\n      this.registerTSNodeInNodeMap(node, result);\n      return result;\n    }\n    // TypeScript@<5.1 has to manually parse the JSX attributes\n    const text = node.getText();\n    const colonIndex = text.indexOf(':');\n    // this is intentional we can ignore conversion if `:` is in first character\n    if (colonIndex > 0) {\n      const range = (0, node_utils_1.getRange)(node, this.ast);\n      // @ts-expect-error -- TypeScript@<5.1 doesn't have ts.JsxNamespacedName\n      const result = this.createNode(node, {\n        type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n        namespace: this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: text.slice(0, colonIndex),\n          range: [range[0], range[0] + colonIndex]\n        }),\n        name: this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: text.slice(colonIndex + 1),\n          range: [range[0] + colonIndex + 1, range[1]]\n        }),\n        range\n      });\n      this.registerTSNodeInNodeMap(node, result);\n      return result;\n    }\n    return this.convertJSXIdentifier(node);\n  }\n  /**\n   * Converts a TypeScript JSX node.tagName into an ESTree node.name\n   * @param node the tagName object from a JSX ts.Node\n   * @param parent\n   * @returns the converted ESTree name object\n   */\n  convertJSXTagName(node, parent) {\n    let result;\n    switch (node.kind) {\n      case SyntaxKind.PropertyAccessExpression:\n        if (node.name.kind === SyntaxKind.PrivateIdentifier) {\n          // This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.\n          // So we shouldn't ever get into this state to begin with.\n          throw new Error('Non-private identifier expected.');\n        }\n        result = this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,\n          object: this.convertJSXTagName(node.expression, parent),\n          property: this.convertJSXIdentifier(node.name)\n        });\n        break;\n      case SyntaxKind.ThisKeyword:\n      case SyntaxKind.Identifier:\n      default:\n        return this.convertJSXNamespaceOrIdentifier(node);\n    }\n    this.registerTSNodeInNodeMap(node, result);\n    return result;\n  }\n  convertMethodSignature(node) {\n    const result = this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,\n      computed: (0, node_utils_1.isComputedProperty)(node.name),\n      key: this.convertChild(node.name),\n      params: this.convertParameters(node.parameters),\n      kind: (() => {\n        switch (node.kind) {\n          case SyntaxKind.GetAccessor:\n            return 'get';\n          case SyntaxKind.SetAccessor:\n            return 'set';\n          case SyntaxKind.MethodSignature:\n            return 'method';\n        }\n      })()\n    });\n    if ((0, node_utils_1.isOptional)(node)) {\n      result.optional = true;\n    }\n    if (node.type) {\n      result.returnType = this.convertTypeAnnotation(node.type, node);\n    }\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {\n      result.readonly = true;\n    }\n    if (node.typeParameters) {\n      result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n    }\n    const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n    if (accessibility) {\n      result.accessibility = accessibility;\n    }\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {\n      result.export = true;\n    }\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {\n      result.static = true;\n    }\n    return result;\n  }\n  convertAssertClasue(node) {\n    return node === undefined ? [] : node.elements.map(element => this.convertChild(element));\n  }\n  /**\n   * Applies the given TS modifiers to the given result object.\n   *\n   * This method adds not standardized `modifiers` property in nodes\n   *\n   * @param result\n   * @param modifiers original ts.Nodes from the node.modifiers array\n   * @returns the current result object will be mutated\n   */\n  applyModifiersToResult(result, modifiers) {\n    if (!modifiers) {\n      return;\n    }\n    const remainingModifiers = [];\n    /**\n     * Some modifiers are explicitly handled by applying them as\n     * boolean values on the result node. As well as adding them\n     * to the result, we remove them from the array, so that they\n     * are not handled twice.\n     */\n    for (const modifier of modifiers) {\n      switch (modifier.kind) {\n        /**\n         * Ignore ExportKeyword and DefaultKeyword, they are handled\n         * via the fixExports utility function\n         */\n        case SyntaxKind.ExportKeyword:\n        case SyntaxKind.DefaultKeyword:\n          break;\n        case SyntaxKind.ConstKeyword:\n          result.const = true;\n          break;\n        case SyntaxKind.DeclareKeyword:\n          result.declare = true;\n          break;\n        default:\n          remainingModifiers.push(this.convertChild(modifier));\n          break;\n      }\n    }\n    /**\n     * If there are still valid modifiers available which have\n     * not been explicitly handled above, we just convert and\n     * add the modifiers array to the result node.\n     */\n    if (remainingModifiers.length > 0) {\n      result.modifiers = remainingModifiers;\n    }\n  }\n  /**\n   * Uses the provided range location to adjust the location data of the given Node\n   * @param result The node that will have its location data mutated\n   * @param childRange The child node range used to expand location\n   */\n  fixParentLocation(result, childRange) {\n    if (childRange[0] < result.range[0]) {\n      result.range[0] = childRange[0];\n      result.loc.start = (0, node_utils_1.getLineAndCharacterFor)(result.range[0], this.ast);\n    }\n    if (childRange[1] > result.range[1]) {\n      result.range[1] = childRange[1];\n      result.loc.end = (0, node_utils_1.getLineAndCharacterFor)(result.range[1], this.ast);\n    }\n  }\n  assertModuleSpecifier(node, allowNull) {\n    var _a;\n    if (!allowNull && node.moduleSpecifier == null) {\n      throw (0, node_utils_1.createError)(this.ast, node.pos, 'Module specifier must be a string literal.');\n    }\n    if (node.moduleSpecifier && ((_a = node.moduleSpecifier) === null || _a === void 0 ? void 0 : _a.kind) !== SyntaxKind.StringLiteral) {\n      throw (0, node_utils_1.createError)(this.ast, node.moduleSpecifier.pos, 'Module specifier must be a string literal.');\n    }\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * The core of the conversion logic:\n   * Identify and convert each relevant TypeScript SyntaxKind\n   * @param node the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertNode(node, parent) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    switch (node.kind) {\n      case SyntaxKind.SourceFile:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Program,\n            body: this.convertBodyExpressions(node.statements, node),\n            sourceType: node.externalModuleIndicator ? 'module' : 'script',\n            range: [node.getStart(this.ast), node.endOfFileToken.end]\n          });\n        }\n      case SyntaxKind.Block:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.BlockStatement,\n            body: this.convertBodyExpressions(node.statements, node)\n          });\n        }\n      case SyntaxKind.Identifier:\n        {\n          if ((0, node_utils_1.isThisInTypeQuery)(node)) {\n            // special case for `typeof this.foo` - TS emits an Identifier for `this`\n            // but we want to treat it as a ThisExpression for consistency\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ThisExpression\n            });\n          }\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n            name: node.text\n          });\n        }\n      case SyntaxKind.PrivateIdentifier:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,\n            // typescript includes the `#` in the text\n            name: node.text.slice(1)\n          });\n        }\n      case SyntaxKind.WithStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.WithStatement,\n          object: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      // Control Flow\n      case SyntaxKind.ReturnStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.LabeledStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,\n          label: this.convertChild(node.label),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ContinueStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,\n          label: this.convertChild(node.label)\n        });\n      case SyntaxKind.BreakStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.BreakStatement,\n          label: this.convertChild(node.label)\n        });\n      // Choice\n      case SyntaxKind.IfStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.IfStatement,\n          test: this.convertChild(node.expression),\n          consequent: this.convertChild(node.thenStatement),\n          alternate: this.convertChild(node.elseStatement)\n        });\n      case SyntaxKind.SwitchStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,\n          discriminant: this.convertChild(node.expression),\n          cases: node.caseBlock.clauses.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.CaseClause:\n      case SyntaxKind.DefaultClause:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.SwitchCase,\n          // expression is present in case only\n          test: node.kind === SyntaxKind.CaseClause ? this.convertChild(node.expression) : null,\n          consequent: node.statements.map(el => this.convertChild(el))\n        });\n      // Exceptions\n      case SyntaxKind.ThrowStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.TryStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TryStatement,\n          block: this.convertChild(node.tryBlock),\n          handler: this.convertChild(node.catchClause),\n          finalizer: this.convertChild(node.finallyBlock)\n        });\n      case SyntaxKind.CatchClause:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.CatchClause,\n          param: node.variableDeclaration ? this.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type) : null,\n          body: this.convertChild(node.block)\n        });\n      // Loops\n      case SyntaxKind.WhileStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.WhileStatement,\n          test: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      /**\n       * Unlike other parsers, TypeScript calls a \"DoWhileStatement\"\n       * a \"DoStatement\"\n       */\n      case SyntaxKind.DoStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,\n          test: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ForStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForStatement,\n          init: this.convertChild(node.initializer),\n          test: this.convertChild(node.condition),\n          update: this.convertChild(node.incrementor),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ForInStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForInStatement,\n          left: this.convertPattern(node.initializer),\n          right: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ForOfStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,\n          left: this.convertPattern(node.initializer),\n          right: this.convertChild(node.expression),\n          body: this.convertChild(node.statement),\n          await: Boolean(node.awaitModifier && node.awaitModifier.kind === SyntaxKind.AwaitKeyword)\n        });\n      // Declarations\n      case SyntaxKind.FunctionDeclaration:\n        {\n          const isDeclare = (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);\n          const result = this.createNode(node, {\n            type: isDeclare || !node.body ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,\n            id: this.convertChild(node.name),\n            generator: !!node.asteriskToken,\n            expression: false,\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body) || undefined\n          });\n          // Process returnType\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          if (isDeclare) {\n            result.declare = true;\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.VariableDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,\n            id: this.convertBindingNameWithTypeAnnotation(node.name, node.type, node),\n            init: this.convertChild(node.initializer)\n          });\n          if (node.exclamationToken) {\n            result.definite = true;\n          }\n          return result;\n        }\n      case SyntaxKind.VariableStatement:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n            declarations: node.declarationList.declarations.map(el => this.convertChild(el)),\n            kind: (0, node_utils_1.getDeclarationKind)(node.declarationList)\n          });\n          /**\n           * Semantically, decorators are not allowed on variable declarations,\n           * Pre 4.8 TS would include them in the AST, so we did as well.\n           * However as of 4.8 TS no longer includes it (as it is, well, invalid).\n           *\n           * So for consistency across versions, we no longer include it either.\n           */\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      // mostly for for-of, for-in\n      case SyntaxKind.VariableDeclarationList:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n          declarations: node.declarations.map(el => this.convertChild(el)),\n          kind: (0, node_utils_1.getDeclarationKind)(node)\n        });\n      // Expressions\n      case SyntaxKind.ExpressionStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,\n          expression: this.convertChild(node.expression)\n        });\n      case SyntaxKind.ThisKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ThisExpression\n        });\n      case SyntaxKind.ArrayLiteralExpression:\n        {\n          // TypeScript uses ArrayLiteralExpression in destructuring assignment, too\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n              elements: node.elements.map(el => this.convertPattern(el))\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,\n              elements: node.elements.map(el => this.convertChild(el))\n            });\n          }\n        }\n      case SyntaxKind.ObjectLiteralExpression:\n        {\n          // TypeScript uses ObjectLiteralExpression in destructuring assignment, too\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n              properties: node.properties.map(el => this.convertPattern(el))\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,\n              properties: node.properties.map(el => this.convertChild(el))\n            });\n          }\n        }\n      case SyntaxKind.PropertyAssignment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Property,\n          key: this.convertChild(node.name),\n          value: this.converter(node.initializer, node, this.inTypeMode, this.allowPattern),\n          computed: (0, node_utils_1.isComputedProperty)(node.name),\n          method: false,\n          shorthand: false,\n          kind: 'init'\n        });\n      case SyntaxKind.ShorthandPropertyAssignment:\n        {\n          if (node.objectAssignmentInitializer) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertPattern(node.name),\n                right: this.convertChild(node.objectAssignmentInitializer)\n              }),\n              computed: false,\n              method: false,\n              shorthand: true,\n              kind: 'init'\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: this.convertChild(node.name),\n              computed: false,\n              method: false,\n              shorthand: true,\n              kind: 'init'\n            });\n          }\n        }\n      case SyntaxKind.ComputedPropertyName:\n        return this.convertChild(node.expression);\n      case SyntaxKind.PropertyDeclaration:\n        {\n          const isAbstract = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);\n          const isAccessor = (0, node_utils_1.hasModifier)(SyntaxKind.AccessorKeyword, node);\n          // eslint-disable-next-line @typescript-eslint/explicit-function-return-type -- TODO - add ignore IIFE option\n          const type = (() => {\n            if (isAccessor) {\n              if (isAbstract) {\n                return ts_estree_1.AST_NODE_TYPES.TSAbstractAccessorProperty;\n              }\n              return ts_estree_1.AST_NODE_TYPES.AccessorProperty;\n            }\n            if (isAbstract) {\n              return ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition;\n            }\n            return ts_estree_1.AST_NODE_TYPES.PropertyDefinition;\n          })();\n          const result = this.createNode(node, {\n            type,\n            key: this.convertChild(node.name),\n            value: isAbstract ? null : this.convertChild(node.initializer),\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n            declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n            override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)\n          });\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n          }\n          const decorators = (0, getModifiers_1.getDecorators)(node);\n          if (decorators) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n          }\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          if ((node.name.kind === SyntaxKind.Identifier || node.name.kind === SyntaxKind.ComputedPropertyName || node.name.kind === SyntaxKind.PrivateIdentifier) && node.questionToken) {\n            result.optional = true;\n          }\n          if (node.exclamationToken) {\n            result.definite = true;\n          }\n          if (result.key.type === ts_estree_1.AST_NODE_TYPES.Literal && node.questionToken) {\n            result.optional = true;\n          }\n          return result;\n        }\n      case SyntaxKind.GetAccessor:\n      case SyntaxKind.SetAccessor:\n        {\n          if (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) {\n            return this.convertMethodSignature(node);\n          }\n        }\n      // otherwise, it is a non-type accessor - intentional fallthrough\n      case SyntaxKind.MethodDeclaration:\n        {\n          const method = this.createNode(node, {\n            type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: null,\n            generator: !!node.asteriskToken,\n            expression: false,\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            body: this.convertChild(node.body),\n            range: [node.parameters.pos - 1, node.end],\n            params: []\n          });\n          if (node.type) {\n            method.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            method.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n            this.fixParentLocation(method, method.typeParameters.range);\n          }\n          let result;\n          if (parent.kind === SyntaxKind.ObjectLiteralExpression) {\n            method.params = node.parameters.map(el => this.convertChild(el));\n            result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: method,\n              computed: (0, node_utils_1.isComputedProperty)(node.name),\n              method: node.kind === SyntaxKind.MethodDeclaration,\n              shorthand: false,\n              kind: 'init'\n            });\n          } else {\n            // class\n            /**\n             * Unlike in object literal methods, class method params can have decorators\n             */\n            method.params = this.convertParameters(node.parameters);\n            /**\n             * TypeScript class methods can be defined as \"abstract\"\n             */\n            const methodDefinitionType = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition;\n            result = this.createNode(node, {\n              type: methodDefinitionType,\n              key: this.convertChild(node.name),\n              value: method,\n              computed: (0, node_utils_1.isComputedProperty)(node.name),\n              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n              kind: 'method',\n              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)\n            });\n            const decorators = (0, getModifiers_1.getDecorators)(node);\n            if (decorators) {\n              result.decorators = decorators.map(el => this.convertChild(el));\n            }\n            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n            if (accessibility) {\n              result.accessibility = accessibility;\n            }\n          }\n          if (node.questionToken) {\n            result.optional = true;\n          }\n          if (node.kind === SyntaxKind.GetAccessor) {\n            result.kind = 'get';\n          } else if (node.kind === SyntaxKind.SetAccessor) {\n            result.kind = 'set';\n          } else if (!result.static && node.name.kind === SyntaxKind.StringLiteral && node.name.text === 'constructor' && result.type !== ts_estree_1.AST_NODE_TYPES.Property) {\n            result.kind = 'constructor';\n          }\n          return result;\n        }\n      // TypeScript uses this even for static methods named \"constructor\"\n      case SyntaxKind.Constructor:\n        {\n          const lastModifier = (0, node_utils_1.getLastModifier)(node);\n          const constructorToken = lastModifier && (0, node_utils_1.findNextToken)(lastModifier, node, this.ast) || node.getFirstToken();\n          const constructor = this.createNode(node, {\n            type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: null,\n            params: this.convertParameters(node.parameters),\n            generator: false,\n            expression: false,\n            async: false,\n            body: this.convertChild(node.body),\n            range: [node.parameters.pos - 1, node.end]\n          });\n          // Process typeParameters\n          if (node.typeParameters) {\n            constructor.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n            this.fixParentLocation(constructor, constructor.typeParameters.range);\n          }\n          // Process returnType\n          if (node.type) {\n            constructor.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          const constructorKey = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n            name: 'constructor',\n            range: [constructorToken.getStart(this.ast), constructorToken.end]\n          });\n          const isStatic = (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);\n          const result = this.createNode(node, {\n            type: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition,\n            key: constructorKey,\n            value: constructor,\n            computed: false,\n            static: isStatic,\n            kind: isStatic ? 'method' : 'constructor',\n            override: false\n          });\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          return result;\n        }\n      case SyntaxKind.FunctionExpression:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: this.convertChild(node.name),\n            generator: !!node.asteriskToken,\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body),\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            expression: false\n          });\n          // Process returnType\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.SuperKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Super\n        });\n      case SyntaxKind.ArrayBindingPattern:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n          elements: node.elements.map(el => this.convertPattern(el))\n        });\n      // occurs with missing array elements like [,]\n      case SyntaxKind.OmittedExpression:\n        return null;\n      case SyntaxKind.ObjectBindingPattern:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n          properties: node.elements.map(el => this.convertPattern(el))\n        });\n      case SyntaxKind.BindingElement:\n        {\n          if (parent.kind === SyntaxKind.ArrayBindingPattern) {\n            const arrayItem = this.convertChild(node.name, parent);\n            if (node.initializer) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: arrayItem,\n                right: this.convertChild(node.initializer)\n              });\n            } else if (node.dotDotDotToken) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                argument: arrayItem\n              });\n            } else {\n              return arrayItem;\n            }\n          } else {\n            let result;\n            if (node.dotDotDotToken) {\n              result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                argument: this.convertChild((_a = node.propertyName) !== null && _a !== void 0 ? _a : node.name)\n              });\n            } else {\n              result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.Property,\n                key: this.convertChild((_b = node.propertyName) !== null && _b !== void 0 ? _b : node.name),\n                value: this.convertChild(node.name),\n                computed: Boolean(node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName),\n                method: false,\n                shorthand: !node.propertyName,\n                kind: 'init'\n              });\n            }\n            if (node.initializer) {\n              result.value = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertChild(node.name),\n                right: this.convertChild(node.initializer),\n                range: [node.name.getStart(this.ast), node.initializer.end]\n              });\n            }\n            return result;\n          }\n        }\n      case SyntaxKind.ArrowFunction:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,\n            generator: false,\n            id: null,\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body),\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            expression: node.body.kind !== SyntaxKind.Block\n          });\n          // Process returnType\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.YieldExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.YieldExpression,\n          delegate: !!node.asteriskToken,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.AwaitExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,\n          argument: this.convertChild(node.expression)\n        });\n      // Template Literals\n      case SyntaxKind.NoSubstitutionTemplateLiteral:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n          quasis: [this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n            value: {\n              raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - 1),\n              cooked: node.text\n            },\n            tail: true\n          })],\n          expressions: []\n        });\n      case SyntaxKind.TemplateExpression:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n            quasis: [this.convertChild(node.head)],\n            expressions: []\n          });\n          node.templateSpans.forEach(templateSpan => {\n            result.expressions.push(this.convertChild(templateSpan.expression));\n            result.quasis.push(this.convertChild(templateSpan.literal));\n          });\n          return result;\n        }\n      case SyntaxKind.TaggedTemplateExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n          tag: this.convertChild(node.tag),\n          quasi: this.convertChild(node.template)\n        });\n      case SyntaxKind.TemplateHead:\n      case SyntaxKind.TemplateMiddle:\n      case SyntaxKind.TemplateTail:\n        {\n          const tail = node.kind === SyntaxKind.TemplateTail;\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n            value: {\n              raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - (tail ? 1 : 2)),\n              cooked: node.text\n            },\n            tail\n          });\n        }\n      // Patterns\n      case SyntaxKind.SpreadAssignment:\n      case SyntaxKind.SpreadElement:\n        {\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.RestElement,\n              argument: this.convertPattern(node.expression)\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.SpreadElement,\n              argument: this.convertChild(node.expression)\n            });\n          }\n        }\n      case SyntaxKind.Parameter:\n        {\n          let parameter;\n          let result;\n          if (node.dotDotDotToken) {\n            parameter = result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.RestElement,\n              argument: this.convertChild(node.name)\n            });\n          } else if (node.initializer) {\n            parameter = this.convertChild(node.name);\n            result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n              left: parameter,\n              right: this.convertChild(node.initializer)\n            });\n            const modifiers = (0, getModifiers_1.getModifiers)(node);\n            if (modifiers) {\n              // AssignmentPattern should not contain modifiers in range\n              result.range[0] = parameter.range[0];\n              result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n            }\n          } else {\n            parameter = result = this.convertChild(node.name, parent);\n          }\n          if (node.type) {\n            parameter.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n            this.fixParentLocation(parameter, parameter.typeAnnotation.range);\n          }\n          if (node.questionToken) {\n            if (node.questionToken.end > parameter.range[1]) {\n              parameter.range[1] = node.questionToken.end;\n              parameter.loc.end = (0, node_utils_1.getLineAndCharacterFor)(parameter.range[1], this.ast);\n            }\n            parameter.optional = true;\n          }\n          const modifiers = (0, getModifiers_1.getModifiers)(node);\n          if (modifiers) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,\n              accessibility: (_c = (0, node_utils_1.getTSNodeAccessibility)(node)) !== null && _c !== void 0 ? _c : undefined,\n              readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,\n              export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined,\n              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node) || undefined,\n              parameter: result\n            });\n          }\n          return result;\n        }\n      // Classes\n      case SyntaxKind.ClassDeclaration:\n      case SyntaxKind.ClassExpression:\n        {\n          const heritageClauses = (_d = node.heritageClauses) !== null && _d !== void 0 ? _d : [];\n          const classNodeType = node.kind === SyntaxKind.ClassDeclaration ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration : ts_estree_1.AST_NODE_TYPES.ClassExpression;\n          const superClass = heritageClauses.find(clause => clause.token === SyntaxKind.ExtendsKeyword);\n          const implementsClause = heritageClauses.find(clause => clause.token === SyntaxKind.ImplementsKeyword);\n          const result = this.createNode(node, {\n            type: classNodeType,\n            id: this.convertChild(node.name),\n            body: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ClassBody,\n              body: [],\n              range: [node.members.pos - 1, node.end]\n            }),\n            superClass: (superClass === null || superClass === void 0 ? void 0 : superClass.types[0]) ? this.convertChild(superClass.types[0].expression) : null\n          });\n          if (superClass) {\n            if (superClass.types.length > 1) {\n              throw (0, node_utils_1.createError)(this.ast, superClass.types[1].pos, 'Classes can only extend a single class.');\n            }\n            if ((_e = superClass.types[0]) === null || _e === void 0 ? void 0 : _e.typeArguments) {\n              result.superTypeParameters = this.convertTypeArgumentsToTypeParameters(superClass.types[0].typeArguments, superClass.types[0]);\n            }\n          }\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          if (implementsClause) {\n            result.implements = implementsClause.types.map(el => this.convertChild(el));\n          }\n          /**\n           * TypeScript class declarations can be defined as \"abstract\"\n           */\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {\n            result.abstract = true;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          const decorators = (0, getModifiers_1.getDecorators)(node);\n          if (decorators) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n          }\n          const filteredMembers = node.members.filter(node_utils_1.isESTreeClassMember);\n          if (filteredMembers.length) {\n            result.body.body = filteredMembers.map(el => this.convertChild(el));\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      // Modules\n      case SyntaxKind.ModuleBlock:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,\n          body: this.convertBodyExpressions(node.statements, node)\n        });\n      case SyntaxKind.ImportDeclaration:\n        {\n          this.assertModuleSpecifier(node, false);\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,\n            source: this.convertChild(node.moduleSpecifier),\n            specifiers: [],\n            importKind: 'value',\n            assertions: this.convertAssertClasue(node.assertClause)\n          });\n          if (node.importClause) {\n            if (node.importClause.isTypeOnly) {\n              result.importKind = 'type';\n            }\n            if (node.importClause.name) {\n              result.specifiers.push(this.convertChild(node.importClause));\n            }\n            if (node.importClause.namedBindings) {\n              switch (node.importClause.namedBindings.kind) {\n                case SyntaxKind.NamespaceImport:\n                  result.specifiers.push(this.convertChild(node.importClause.namedBindings));\n                  break;\n                case SyntaxKind.NamedImports:\n                  result.specifiers = result.specifiers.concat(node.importClause.namedBindings.elements.map(el => this.convertChild(el)));\n                  break;\n              }\n            }\n          }\n          return result;\n        }\n      case SyntaxKind.NamespaceImport:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,\n          local: this.convertChild(node.name)\n        });\n      case SyntaxKind.ImportSpecifier:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,\n          local: this.convertChild(node.name),\n          imported: this.convertChild((_f = node.propertyName) !== null && _f !== void 0 ? _f : node.name),\n          importKind: node.isTypeOnly ? 'type' : 'value'\n        });\n      case SyntaxKind.ImportClause:\n        {\n          const local = this.convertChild(node.name);\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,\n            local,\n            range: local.range\n          });\n        }\n      case SyntaxKind.ExportDeclaration:\n        {\n          if (((_g = node.exportClause) === null || _g === void 0 ? void 0 : _g.kind) === SyntaxKind.NamedExports) {\n            this.assertModuleSpecifier(node, true);\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n              source: this.convertChild(node.moduleSpecifier),\n              specifiers: node.exportClause.elements.map(el => this.convertChild(el)),\n              exportKind: node.isTypeOnly ? 'type' : 'value',\n              declaration: null,\n              assertions: this.convertAssertClasue(node.assertClause)\n            });\n          } else {\n            this.assertModuleSpecifier(node, false);\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,\n              source: this.convertChild(node.moduleSpecifier),\n              exportKind: node.isTypeOnly ? 'type' : 'value',\n              exported:\n              // note - for compat with 3.7.x, where node.exportClause is always undefined and\n              //        SyntaxKind.NamespaceExport does not exist yet (i.e. is undefined), this\n              //        cannot be shortened to an optional chain, or else you end up with\n              //        undefined === undefined, and the true path will hard error at runtime\n              node.exportClause && node.exportClause.kind === SyntaxKind.NamespaceExport ? this.convertChild(node.exportClause.name) : null,\n              assertions: this.convertAssertClasue(node.assertClause)\n            });\n          }\n        }\n      case SyntaxKind.ExportSpecifier:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,\n          local: this.convertChild((_h = node.propertyName) !== null && _h !== void 0 ? _h : node.name),\n          exported: this.convertChild(node.name),\n          exportKind: node.isTypeOnly ? 'type' : 'value'\n        });\n      case SyntaxKind.ExportAssignment:\n        if (node.isExportEquals) {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,\n            expression: this.convertChild(node.expression)\n          });\n        } else {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n            declaration: this.convertChild(node.expression),\n            exportKind: 'value'\n          });\n        }\n      // Unary Operations\n      case SyntaxKind.PrefixUnaryExpression:\n      case SyntaxKind.PostfixUnaryExpression:\n        {\n          const operator = (0, node_utils_1.getTextForTokenKind)(node.operator);\n          /**\n           * ESTree uses UpdateExpression for ++/--\n           */\n          if (operator === '++' || operator === '--') {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,\n              operator,\n              prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n              argument: this.convertChild(node.operand)\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n              operator,\n              prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n              argument: this.convertChild(node.operand)\n            });\n          }\n        }\n      case SyntaxKind.DeleteExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'delete',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.VoidExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'void',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.TypeOfExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'typeof',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.TypeOperator:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,\n          operator: (0, node_utils_1.getTextForTokenKind)(node.operator),\n          typeAnnotation: this.convertChild(node.type)\n        });\n      // Binary Operations\n      case SyntaxKind.BinaryExpression:\n        {\n          // TypeScript uses BinaryExpression for sequences as well\n          if ((0, node_utils_1.isComma)(node.operatorToken)) {\n            const result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,\n              expressions: []\n            });\n            const left = this.convertChild(node.left);\n            if (left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression && node.left.kind !== SyntaxKind.ParenthesizedExpression) {\n              result.expressions = result.expressions.concat(left.expressions);\n            } else {\n              result.expressions.push(left);\n            }\n            result.expressions.push(this.convertChild(node.right));\n            return result;\n          } else {\n            const type = (0, node_utils_1.getBinaryExpressionType)(node.operatorToken);\n            if (this.allowPattern && type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertPattern(node.left, node),\n                right: this.convertChild(node.right)\n              });\n            }\n            return this.createNode(node, {\n              type,\n              operator: (0, node_utils_1.getTextForTokenKind)(node.operatorToken.kind),\n              left: this.converter(node.left, node, this.inTypeMode, type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),\n              right: this.convertChild(node.right)\n            });\n          }\n        }\n      case SyntaxKind.PropertyAccessExpression:\n        {\n          const object = this.convertChild(node.expression);\n          const property = this.convertChild(node.name);\n          const computed = false;\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n            object,\n            property,\n            computed,\n            optional: node.questionDotToken !== undefined\n          });\n          return this.convertChainExpression(result, node);\n        }\n      case SyntaxKind.ElementAccessExpression:\n        {\n          const object = this.convertChild(node.expression);\n          const property = this.convertChild(node.argumentExpression);\n          const computed = true;\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n            object,\n            property,\n            computed,\n            optional: node.questionDotToken !== undefined\n          });\n          return this.convertChainExpression(result, node);\n        }\n      case SyntaxKind.CallExpression:\n        {\n          if (node.expression.kind === SyntaxKind.ImportKeyword) {\n            if (node.arguments.length !== 1 && node.arguments.length !== 2) {\n              throw (0, node_utils_1.createError)(this.ast, node.arguments.pos, 'Dynamic import requires exactly one or two arguments.');\n            }\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ImportExpression,\n              source: this.convertChild(node.arguments[0]),\n              attributes: node.arguments[1] ? this.convertChild(node.arguments[1]) : null\n            });\n          }\n          const callee = this.convertChild(node.expression);\n          const args = node.arguments.map(el => this.convertChild(el));\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.CallExpression,\n            callee,\n            arguments: args,\n            optional: node.questionDotToken !== undefined\n          });\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n          return this.convertChainExpression(result, node);\n        }\n      case SyntaxKind.NewExpression:\n        {\n          // NOTE - NewExpression cannot have an optional chain in it\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.NewExpression,\n            callee: this.convertChild(node.expression),\n            arguments: node.arguments ? node.arguments.map(el => this.convertChild(el)) : []\n          });\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n          return result;\n        }\n      case SyntaxKind.ConditionalExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,\n          test: this.convertChild(node.condition),\n          consequent: this.convertChild(node.whenTrue),\n          alternate: this.convertChild(node.whenFalse)\n        });\n      case SyntaxKind.MetaProperty:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MetaProperty,\n            meta: this.createNode(\n            // TODO: do we really want to convert it to Token?\n            node.getFirstToken(), {\n              type: ts_estree_1.AST_NODE_TYPES.Identifier,\n              name: (0, node_utils_1.getTextForTokenKind)(node.keywordToken)\n            }),\n            property: this.convertChild(node.name)\n          });\n        }\n      case SyntaxKind.Decorator:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Decorator,\n            expression: this.convertChild(node.expression)\n          });\n        }\n      // Literals\n      case SyntaxKind.StringLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: parent.kind === SyntaxKind.JsxAttribute ? (0, node_utils_1.unescapeStringLiteralText)(node.text) : node.text,\n            raw: node.getText()\n          });\n        }\n      case SyntaxKind.NumericLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: Number(node.text),\n            raw: node.getText()\n          });\n        }\n      case SyntaxKind.BigIntLiteral:\n        {\n          const range = (0, node_utils_1.getRange)(node, this.ast);\n          const rawValue = this.ast.text.slice(range[0], range[1]);\n          const bigint = rawValue\n          // remove suffix `n`\n          .slice(0, -1)\n          // `BigInt` doesn't accept numeric separator\n          // and `bigint` property should not include numeric separator\n          .replace(/_/g, '');\n          const value = typeof BigInt !== 'undefined' ? BigInt(bigint) : null;\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            raw: rawValue,\n            value: value,\n            bigint: value == null ? bigint : String(value),\n            range\n          });\n        }\n      case SyntaxKind.RegularExpressionLiteral:\n        {\n          const pattern = node.text.slice(1, node.text.lastIndexOf('/'));\n          const flags = node.text.slice(node.text.lastIndexOf('/') + 1);\n          let regex = null;\n          try {\n            regex = new RegExp(pattern, flags);\n          } catch (exception) {\n            regex = null;\n          }\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: regex,\n            raw: node.text,\n            regex: {\n              pattern,\n              flags\n            }\n          });\n        }\n      case SyntaxKind.TrueKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Literal,\n          value: true,\n          raw: 'true'\n        });\n      case SyntaxKind.FalseKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Literal,\n          value: false,\n          raw: 'false'\n        });\n      case SyntaxKind.NullKeyword:\n        {\n          if (!version_check_1.typescriptVersionIsAtLeast['4.0'] && this.inTypeMode) {\n            // 4.0 started nesting null types inside a LiteralType node, but we still need to support pre-4.0\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword\n            });\n          }\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: null,\n            raw: 'null'\n          });\n        }\n      case SyntaxKind.EmptyStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.EmptyStatement\n        });\n      case SyntaxKind.DebuggerStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement\n        });\n      // JSX\n      case SyntaxKind.JsxElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n          openingElement: this.convertChild(node.openingElement),\n          closingElement: this.convertChild(node.closingElement),\n          children: node.children.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.JsxFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXFragment,\n          openingFragment: this.convertChild(node.openingFragment),\n          closingFragment: this.convertChild(node.closingFragment),\n          children: node.children.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.JsxSelfClosingElement:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n            /**\n             * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,\n             * TypeScript does not seem to have the idea of openingElement when tag is self-closing\n             */\n            openingElement: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n              selfClosing: true,\n              name: this.convertJSXTagName(node.tagName, node),\n              attributes: node.attributes.properties.map(el => this.convertChild(el)),\n              range: (0, node_utils_1.getRange)(node, this.ast)\n            }),\n            closingElement: null,\n            children: []\n          });\n        }\n      case SyntaxKind.JsxOpeningElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n          selfClosing: false,\n          name: this.convertJSXTagName(node.tagName, node),\n          attributes: node.attributes.properties.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.JsxClosingElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,\n          name: this.convertJSXTagName(node.tagName, node)\n        });\n      case SyntaxKind.JsxOpeningFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment\n        });\n      case SyntaxKind.JsxClosingFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment\n        });\n      case SyntaxKind.JsxExpression:\n        {\n          const expression = node.expression ? this.convertChild(node.expression) : this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,\n            range: [node.getStart(this.ast) + 1, node.getEnd() - 1]\n          });\n          if (node.dotDotDotToken) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,\n              expression\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,\n              expression\n            });\n          }\n        }\n      case SyntaxKind.JsxAttribute:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,\n            name: this.convertJSXNamespaceOrIdentifier(node.name),\n            value: this.convertChild(node.initializer)\n          });\n        }\n      case SyntaxKind.JsxText:\n        {\n          const start = node.getFullStart();\n          const end = node.getEnd();\n          const text = this.ast.text.slice(start, end);\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXText,\n            value: (0, node_utils_1.unescapeStringLiteralText)(text),\n            raw: text,\n            range: [start, end]\n          });\n        }\n      case SyntaxKind.JsxSpreadAttribute:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.QualifiedName:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,\n            left: this.convertChild(node.left),\n            right: this.convertChild(node.right)\n          });\n        }\n      // TypeScript specific\n      case SyntaxKind.TypeReference:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,\n            typeName: this.convertType(node.typeName),\n            typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined\n          });\n        }\n      case SyntaxKind.TypeParameter:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,\n            name: this.convertType(node.name),\n            constraint: node.constraint ? this.convertType(node.constraint) : undefined,\n            default: node.default ? this.convertType(node.default) : undefined,\n            in: (0, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),\n            out: (0, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node),\n            const: (0, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node)\n          });\n        }\n      case SyntaxKind.ThisType:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSThisType\n        });\n      case SyntaxKind.AnyKeyword:\n      case SyntaxKind.BigIntKeyword:\n      case SyntaxKind.BooleanKeyword:\n      case SyntaxKind.NeverKeyword:\n      case SyntaxKind.NumberKeyword:\n      case SyntaxKind.ObjectKeyword:\n      case SyntaxKind.StringKeyword:\n      case SyntaxKind.SymbolKeyword:\n      case SyntaxKind.UnknownKeyword:\n      case SyntaxKind.VoidKeyword:\n      case SyntaxKind.UndefinedKeyword:\n      case SyntaxKind.IntrinsicKeyword:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES[`TS${SyntaxKind[node.kind]}`]\n          });\n        }\n      case SyntaxKind.NonNullExpression:\n        {\n          const nnExpr = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,\n            expression: this.convertChild(node.expression)\n          });\n          return this.convertChainExpression(nnExpr, node);\n        }\n      case SyntaxKind.TypeLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,\n            members: node.members.map(el => this.convertChild(el))\n          });\n        }\n      case SyntaxKind.ArrayType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSArrayType,\n            elementType: this.convertType(node.elementType)\n          });\n        }\n      case SyntaxKind.IndexedAccessType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,\n            objectType: this.convertType(node.objectType),\n            indexType: this.convertType(node.indexType)\n          });\n        }\n      case SyntaxKind.ConditionalType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,\n            checkType: this.convertType(node.checkType),\n            extendsType: this.convertType(node.extendsType),\n            trueType: this.convertType(node.trueType),\n            falseType: this.convertType(node.falseType)\n          });\n        }\n      case SyntaxKind.TypeQuery:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,\n            exprName: this.convertType(node.exprName),\n            typeParameters: node.typeArguments && this.convertTypeArgumentsToTypeParameters(node.typeArguments, node)\n          });\n        }\n      case SyntaxKind.MappedType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSMappedType,\n            typeParameter: this.convertType(node.typeParameter),\n            nameType: (_j = this.convertType(node.nameType)) !== null && _j !== void 0 ? _j : null\n          });\n          if (node.readonlyToken) {\n            if (node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {\n              result.readonly = true;\n            } else {\n              result.readonly = (0, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind);\n            }\n          }\n          if (node.questionToken) {\n            if (node.questionToken.kind === SyntaxKind.QuestionToken) {\n              result.optional = true;\n            } else {\n              result.optional = (0, node_utils_1.getTextForTokenKind)(node.questionToken.kind);\n            }\n          }\n          if (node.type) {\n            result.typeAnnotation = this.convertType(node.type);\n          }\n          return result;\n        }\n      case SyntaxKind.ParenthesizedExpression:\n        return this.convertChild(node.expression, parent);\n      case SyntaxKind.TypeAliasDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n            id: this.convertChild(node.name),\n            typeAnnotation: this.convertType(node.type)\n          });\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.MethodSignature:\n        {\n          return this.convertMethodSignature(node);\n        }\n      case SyntaxKind.PropertySignature:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,\n            optional: (0, node_utils_1.isOptional)(node) || undefined,\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            key: this.convertChild(node.name),\n            typeAnnotation: node.type ? this.convertTypeAnnotation(node.type, node) : undefined,\n            initializer: this.convertChild(\n            // @ts-expect-error TODO breaking change remove this from the AST\n            node.initializer) || undefined,\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,\n            export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined\n          });\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          return result;\n        }\n      case SyntaxKind.IndexSignature:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,\n            parameters: node.parameters.map(el => this.convertChild(el))\n          });\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {\n            result.readonly = true;\n          }\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {\n            result.export = true;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {\n            result.static = true;\n          }\n          return result;\n        }\n      case SyntaxKind.ConstructorType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,\n            params: this.convertParameters(node.parameters),\n            abstract: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)\n          });\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.FunctionType:\n      case SyntaxKind.ConstructSignature:\n      case SyntaxKind.CallSignature:\n        {\n          const type = node.kind === SyntaxKind.ConstructSignature ? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration : node.kind === SyntaxKind.CallSignature ? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration : ts_estree_1.AST_NODE_TYPES.TSFunctionType;\n          const result = this.createNode(node, {\n            type: type,\n            params: this.convertParameters(node.parameters)\n          });\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.ExpressionWithTypeArguments:\n        {\n          const parentKind = parent.kind;\n          const type = parentKind === SyntaxKind.InterfaceDeclaration ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage : parentKind === SyntaxKind.HeritageClause ? ts_estree_1.AST_NODE_TYPES.TSClassImplements : ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;\n          const result = this.createNode(node, {\n            type,\n            expression: this.convertChild(node.expression)\n          });\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n          return result;\n        }\n      case SyntaxKind.InterfaceDeclaration:\n        {\n          const interfaceHeritageClauses = (_k = node.heritageClauses) !== null && _k !== void 0 ? _k : [];\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n            body: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,\n              body: node.members.map(member => this.convertChild(member)),\n              range: [node.members.pos - 1, node.end]\n            }),\n            id: this.convertChild(node.name)\n          });\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          if (interfaceHeritageClauses.length > 0) {\n            const interfaceExtends = [];\n            const interfaceImplements = [];\n            for (const heritageClause of interfaceHeritageClauses) {\n              if (heritageClause.token === SyntaxKind.ExtendsKeyword) {\n                for (const n of heritageClause.types) {\n                  interfaceExtends.push(this.convertChild(n, node));\n                }\n              } else {\n                for (const n of heritageClause.types) {\n                  interfaceImplements.push(this.convertChild(n, node));\n                }\n              }\n            }\n            if (interfaceExtends.length) {\n              result.extends = interfaceExtends;\n            }\n            if (interfaceImplements.length) {\n              result.implements = interfaceImplements;\n            }\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {\n            result.abstract = true;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.TypePredicate:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,\n            asserts: node.assertsModifier !== undefined,\n            parameterName: this.convertChild(node.parameterName),\n            typeAnnotation: null\n          });\n          /**\n           * Specific fix for type-guard location data\n           */\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n            result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;\n            result.typeAnnotation.range = result.typeAnnotation.typeAnnotation.range;\n          }\n          return result;\n        }\n      case SyntaxKind.ImportType:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSImportType,\n          isTypeOf: !!node.isTypeOf,\n          parameter: this.convertChild(node.argument),\n          qualifier: this.convertChild(node.qualifier),\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null\n        });\n      case SyntaxKind.EnumDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,\n            id: this.convertChild(node.name),\n            members: node.members.map(el => this.convertChild(el))\n          });\n          // apply modifiers first...\n          this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));\n          // ...then check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.EnumMember:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,\n            id: this.convertChild(node.name)\n          });\n          if (node.initializer) {\n            result.initializer = this.convertChild(node.initializer);\n          }\n          if (node.name.kind === ts.SyntaxKind.ComputedPropertyName) {\n            result.computed = true;\n          }\n          return result;\n        }\n      case SyntaxKind.ModuleDeclaration:\n        {\n          const result = this.createNode(node, Object.assign({\n            type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration\n          }, (() => {\n            const id = this.convertChild(node.name);\n            const body = this.convertChild(node.body);\n            // the constraints checked by this function are syntactically enforced by TS\n            // the checks mostly exist for type's sake\n            if (node.flags & ts.NodeFlags.GlobalAugmentation) {\n              if (body == null || body.type === ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration) {\n                throw new Error('Expected a valid module body');\n              }\n              if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                throw new Error('global module augmentation must have an Identifier id');\n              }\n              return {\n                kind: 'global',\n                id,\n                body,\n                global: true\n              };\n            } else if (node.flags & ts.NodeFlags.Namespace) {\n              if (body == null) {\n                throw new Error('Expected a module body');\n              }\n              if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                throw new Error('`namespace`s must have an Identifier id');\n              }\n              return {\n                kind: 'namespace',\n                id,\n                body\n              };\n            } else {\n              return Object.assign({\n                kind: 'module',\n                id\n              }, body != null ? {\n                body\n              } : {});\n            }\n          })()));\n          this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));\n          // ...then check for exports\n          return this.fixExports(node, result);\n        }\n      // TypeScript specific types\n      case SyntaxKind.ParenthesizedType:\n        {\n          return this.convertType(node.type);\n        }\n      case SyntaxKind.UnionType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSUnionType,\n            types: node.types.map(el => this.convertType(el))\n          });\n        }\n      case SyntaxKind.IntersectionType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,\n            types: node.types.map(el => this.convertType(el))\n          });\n        }\n      case SyntaxKind.AsExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,\n            expression: this.convertChild(node.expression),\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      case SyntaxKind.InferType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSInferType,\n            typeParameter: this.convertType(node.typeParameter)\n          });\n        }\n      case SyntaxKind.LiteralType:\n        {\n          if (version_check_1.typescriptVersionIsAtLeast['4.0'] && node.literal.kind === SyntaxKind.NullKeyword) {\n            // 4.0 started nesting null types inside a LiteralType node\n            // but our AST is designed around the old way of null being a keyword\n            return this.createNode(node.literal, {\n              type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,\n              literal: this.convertType(node.literal)\n            });\n          }\n        }\n      case SyntaxKind.TypeAssertionExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,\n            typeAnnotation: this.convertType(node.type),\n            expression: this.convertChild(node.expression)\n          });\n        }\n      case SyntaxKind.ImportEqualsDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,\n            id: this.convertChild(node.name),\n            moduleReference: this.convertChild(node.moduleReference),\n            importKind: node.isTypeOnly ? 'type' : 'value',\n            isExport: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)\n          });\n        }\n      case SyntaxKind.ExternalModuleReference:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,\n            expression: this.convertChild(node.expression)\n          });\n        }\n      case SyntaxKind.NamespaceExportDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,\n            id: this.convertChild(node.name)\n          });\n        }\n      case SyntaxKind.AbstractKeyword:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword\n          });\n        }\n      // Tuple\n      case SyntaxKind.TupleType:\n        {\n          // In TS 4.0, the `elementTypes` property was changed to `elements`.\n          // To support both at compile time, we cast to access the newer version\n          // if the former does not exist.\n          const elementTypes = 'elementTypes' in node ? node.elementTypes.map(el => this.convertType(el)) : node.elements.map(el => this.convertType(el));\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTupleType,\n            elementTypes\n          });\n        }\n      case SyntaxKind.NamedTupleMember:\n        {\n          const member = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,\n            elementType: this.convertType(node.type, node),\n            label: this.convertChild(node.name, node),\n            optional: node.questionToken != null\n          });\n          if (node.dotDotDotToken) {\n            // adjust the start to account for the \"...\"\n            member.range[0] = member.label.range[0];\n            member.loc.start = member.label.loc.start;\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n              typeAnnotation: member\n            });\n          }\n          return member;\n        }\n      case SyntaxKind.OptionalType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      case SyntaxKind.RestType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      // Template Literal Types\n      case SyntaxKind.TemplateLiteralType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,\n            quasis: [this.convertChild(node.head)],\n            types: []\n          });\n          node.templateSpans.forEach(templateSpan => {\n            result.types.push(this.convertChild(templateSpan.type));\n            result.quasis.push(this.convertChild(templateSpan.literal));\n          });\n          return result;\n        }\n      case SyntaxKind.ClassStaticBlockDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.StaticBlock,\n            body: this.convertBodyExpressions(node.body.statements, node)\n          });\n        }\n      case SyntaxKind.AssertEntry:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,\n            key: this.convertChild(node.name),\n            value: this.convertChild(node.value)\n          });\n        }\n      case SyntaxKind.SatisfiesExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSSatisfiesExpression,\n            expression: this.convertChild(node.expression),\n            typeAnnotation: this.convertChild(node.type)\n          });\n        }\n      default:\n        return this.deeplyCopy(node);\n    }\n  }\n}\nexports.Converter = Converter;","map":{"version":3,"mappings":"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","names":["SyntaxKind","ts","convertError","error","file","start","message","messageText","exports","Converter","constructor","ast","options","WeakMap","getASTMaps","esTreeNodeToTSNodeMap","tsNodeToESTreeNodeMap","convertProgram","converter","node","parent","inTypeMode","allowPattern","typeMode","pattern","undefined","result","convertNode","registerTSNodeInNodeMap","fixExports","modifiers","kind","ExportKeyword","exportKeyword","nextModifier","declarationIsDefault","DefaultKeyword","varToken","range","getStart","loc","createNode","type","ts_estree_1","ExportDefaultDeclaration","declaration","exportKind","isType","TSInterfaceDeclaration","TSTypeAliasDeclaration","isDeclare","declare","ExportNamedDeclaration","specifiers","source","assertions","shouldPreserveNodeMaps","has","set","convertPattern","child","convertChild","convertType","data","convertBindingNameWithTypeAnnotation","name","tsType","id","typeAnnotation","convertTypeAnnotation","fixParentLocation","offset","FunctionType","ConstructorType","annotationStartCol","getFullStart","end","TSTypeAnnotation","convertBodyExpressions","nodes","allowDirectives","map","statement","expression","isExpressionStatement","isStringLiteral","raw","directive","slice","filter","convertTypeArgumentsToTypeParameters","typeArguments","greaterThanToken","TSTypeParameterInstantiation","pos","params","typeArgument","convertTSTypeParametersToTypeParametersDeclaration","typeParameters","TSTypeParameterDeclaration","typeParameter","convertParameters","parameters","length","param","convertedParam","decorators","el","convertChainExpression","tsNode","isOptional","MemberExpression","object","optional","CallExpression","callee","isChildUnwrappable","newChild","ChainExpression","deeplyCopy","JSDocFunctionType","customType","errorOnUnknownASTType","Error","isTypeNode","KEYS_TO_NOT_COPY","Set","Object","entries","_ref","key","forEach","_ref2","value","Array","isArray","convertJSXIdentifier","JSXIdentifier","getText","convertJSXNamespaceOrIdentifier","JsxNamespacedName","JSXNamespacedName","namespace","text","colonIndex","indexOf","convertJSXTagName","PropertyAccessExpression","PrivateIdentifier","JSXMemberExpression","property","ThisKeyword","Identifier","convertMethodSignature","TSMethodSignature","computed","GetAccessor","SetAccessor","MethodSignature","returnType","ReadonlyKeyword","readonly","accessibility","export","StaticKeyword","static","convertAssertClasue","elements","element","applyModifiersToResult","remainingModifiers","modifier","ConstKeyword","const","DeclareKeyword","push","childRange","assertModuleSpecifier","allowNull","moduleSpecifier","StringLiteral","SourceFile","Program","body","statements","sourceType","externalModuleIndicator","endOfFileToken","Block","BlockStatement","ThisExpression","WithStatement","ReturnStatement","argument","LabeledStatement","label","ContinueStatement","BreakStatement","IfStatement","test","consequent","thenStatement","alternate","elseStatement","SwitchStatement","discriminant","cases","caseBlock","clauses","CaseClause","DefaultClause","SwitchCase","ThrowStatement","TryStatement","block","tryBlock","handler","catchClause","finalizer","finallyBlock","CatchClause","variableDeclaration","WhileStatement","DoStatement","DoWhileStatement","ForStatement","init","initializer","condition","update","incrementor","ForInStatement","left","right","ForOfStatement","await","Boolean","awaitModifier","AwaitKeyword","FunctionDeclaration","TSDeclareFunction","generator","asteriskToken","async","AsyncKeyword","VariableDeclaration","VariableDeclarator","exclamationToken","definite","VariableStatement","declarations","declarationList","VariableDeclarationList","ExpressionStatement","ArrayLiteralExpression","ArrayPattern","ArrayExpression","ObjectLiteralExpression","ObjectPattern","properties","ObjectExpression","PropertyAssignment","Property","method","shorthand","ShorthandPropertyAssignment","objectAssignmentInitializer","AssignmentPattern","ComputedPropertyName","PropertyDeclaration","isAbstract","AbstractKeyword","isAccessor","AccessorKeyword","TSAbstractAccessorProperty","AccessorProperty","TSAbstractPropertyDefinition","PropertyDefinition","override","OverrideKeyword","questionToken","Literal","InterfaceDeclaration","TypeLiteral","MethodDeclaration","TSEmptyBodyFunctionExpression","FunctionExpression","methodDefinitionType","TSAbstractMethodDefinition","MethodDefinition","Constructor","lastModifier","constructorToken","getFirstToken","constructorKey","isStatic","SuperKeyword","Super","ArrayBindingPattern","OmittedExpression","ObjectBindingPattern","BindingElement","arrayItem","dotDotDotToken","RestElement","propertyName","ArrowFunction","ArrowFunctionExpression","YieldExpression","delegate","AwaitExpression","NoSubstitutionTemplateLiteral","TemplateLiteral","quasis","TemplateElement","cooked","tail","expressions","TemplateExpression","head","templateSpans","templateSpan","literal","TaggedTemplateExpression","tag","quasi","template","TemplateHead","TemplateMiddle","TemplateTail","SpreadAssignment","SpreadElement","Parameter","parameter","TSParameterProperty","ClassDeclaration","ClassExpression","heritageClauses","classNodeType","superClass","find","clause","token","ExtendsKeyword","implementsClause","ImplementsKeyword","ClassBody","members","types","superTypeParameters","implements","abstract","filteredMembers","node_utils_1","ModuleBlock","TSModuleBlock","ImportDeclaration","importKind","assertClause","importClause","isTypeOnly","namedBindings","NamespaceImport","NamedImports","concat","ImportNamespaceSpecifier","local","ImportSpecifier","imported","ImportClause","ImportDefaultSpecifier","ExportDeclaration","exportClause","NamedExports","ExportAllDeclaration","exported","NamespaceExport","ExportSpecifier","ExportAssignment","isExportEquals","TSExportAssignment","PrefixUnaryExpression","PostfixUnaryExpression","operator","UpdateExpression","prefix","operand","UnaryExpression","DeleteExpression","VoidExpression","TypeOfExpression","TypeOperator","TSTypeOperator","BinaryExpression","operatorToken","SequenceExpression","ParenthesizedExpression","AssignmentExpression","questionDotToken","ElementAccessExpression","argumentExpression","ImportKeyword","arguments","ImportExpression","attributes","args","NewExpression","ConditionalExpression","whenTrue","whenFalse","MetaProperty","meta","keywordToken","Decorator","JsxAttribute","NumericLiteral","Number","BigIntLiteral","rawValue","bigint","replace","BigInt","String","RegularExpressionLiteral","lastIndexOf","flags","regex","RegExp","exception","TrueKeyword","FalseKeyword","NullKeyword","version_check_1","TSNullKeyword","EmptyStatement","DebuggerStatement","JsxElement","JSXElement","openingElement","closingElement","children","JsxFragment","JSXFragment","openingFragment","closingFragment","JsxSelfClosingElement","JSXOpeningElement","selfClosing","tagName","JsxOpeningElement","JsxClosingElement","JSXClosingElement","JsxOpeningFragment","JSXOpeningFragment","JsxClosingFragment","JSXClosingFragment","JsxExpression","JSXEmptyExpression","getEnd","JSXSpreadChild","JSXExpressionContainer","JSXAttribute","JsxText","JSXText","JsxSpreadAttribute","JSXSpreadAttribute","QualifiedName","TSQualifiedName","TypeReference","TSTypeReference","typeName","TypeParameter","TSTypeParameter","constraint","default","in","InKeyword","out","OutKeyword","ThisType","TSThisType","AnyKeyword","BigIntKeyword","BooleanKeyword","NeverKeyword","NumberKeyword","ObjectKeyword","StringKeyword","SymbolKeyword","UnknownKeyword","VoidKeyword","UndefinedKeyword","IntrinsicKeyword","NonNullExpression","nnExpr","TSNonNullExpression","TSTypeLiteral","ArrayType","TSArrayType","elementType","IndexedAccessType","TSIndexedAccessType","objectType","indexType","ConditionalType","TSConditionalType","checkType","extendsType","trueType","falseType","TypeQuery","TSTypeQuery","exprName","MappedType","TSMappedType","nameType","readonlyToken","QuestionToken","TypeAliasDeclaration","PropertySignature","TSPropertySignature","IndexSignature","TSIndexSignature","TSConstructorType","ConstructSignature","CallSignature","TSConstructSignatureDeclaration","TSCallSignatureDeclaration","TSFunctionType","ExpressionWithTypeArguments","parentKind","TSInterfaceHeritage","HeritageClause","TSClassImplements","TSInstantiationExpression","interfaceHeritageClauses","TSInterfaceBody","member","interfaceExtends","interfaceImplements","heritageClause","n","extends","TypePredicate","TSTypePredicate","asserts","assertsModifier","parameterName","ImportType","TSImportType","isTypeOf","qualifier","EnumDeclaration","TSEnumDeclaration","EnumMember","TSEnumMember","ModuleDeclaration","TSModuleDeclaration","NodeFlags","GlobalAugmentation","global","Namespace","ParenthesizedType","UnionType","TSUnionType","IntersectionType","TSIntersectionType","AsExpression","TSAsExpression","InferType","TSInferType","LiteralType","TSLiteralType","TypeAssertionExpression","TSTypeAssertion","ImportEqualsDeclaration","TSImportEqualsDeclaration","moduleReference","isExport","ExternalModuleReference","TSExternalModuleReference","NamespaceExportDeclaration","TSNamespaceExportDeclaration","TSAbstractKeyword","TupleType","elementTypes","TSTupleType","NamedTupleMember","TSNamedTupleMember","TSRestType","OptionalType","TSOptionalType","RestType","TemplateLiteralType","TSTemplateLiteralType","ClassStaticBlockDeclaration","StaticBlock","AssertEntry","ImportAttribute","SatisfiesExpression","TSSatisfiesExpression"],"sources":["../src/convert.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}