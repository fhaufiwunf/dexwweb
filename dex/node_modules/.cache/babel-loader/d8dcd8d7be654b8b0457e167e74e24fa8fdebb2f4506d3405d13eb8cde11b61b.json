{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n/**\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\n * The latter is due to the presence of the device path at the beginning of the UNC path.\n */\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\nfunction isStaticPattern(pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n    return true;\n  }\n  return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n  const openingBraceIndex = pattern.indexOf('{');\n  if (openingBraceIndex === -1) {\n    return false;\n  }\n  const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n  if (closingBraceIndex === -1) {\n    return false;\n  }\n  const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n  const basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce((collection, pattern) => {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n  const patterns = micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true,\n    keepEscaping: true\n  });\n  /**\n   * Sort the patterns by length so that the same depth patterns are processed side by side.\n   * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`\n   */\n  patterns.sort((a, b) => a.length - b.length);\n  /**\n   * Micromatch can return an empty string in the case of patterns like `{a,}`.\n   */\n  return patterns.filter(pattern => pattern !== '');\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n  let {\n    parts\n  } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  }));\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n  return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(pattern => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(patternRe => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n/**\n * This package only works with forward slashes as a path separator.\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\n */\nfunction removeDuplicateSlashes(pattern) {\n  return pattern.replace(DOUBLE_SLASH_RE, '/');\n}\nexports.removeDuplicateSlashes = removeDuplicateSlashes;","map":{"version":3,"names":["Object","defineProperty","exports","value","removeDuplicateSlashes","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","isPatternRelatedToParentDirectory","getPatternsOutsideCurrentDirectory","getPatternsInsideCurrentDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSION_SEPARATORS_RE","DOUBLE_SLASH_RE","pattern","options","arguments","length","undefined","caseSensitiveMatch","includes","test","extglob","braceExpansion","hasBraceExpansion","openingBraceIndex","indexOf","closingBraceIndex","braceContent","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","keepEscaping","sort","a","b","parts","scan","assign","unshift","map","entry","patternsRe","some","patternRe","replace"],"sources":["C:/Users/ADMIN/node_modules/fast-glob/out/utils/pattern.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n/**\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\n * The latter is due to the presence of the device path at the beginning of the UNC path.\n */\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\nfunction isStaticPattern(pattern, options = {}) {\n    return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n    /**\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n     * An empty string cannot be a dynamic pattern.\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n     */\n    if (pattern === '') {\n        return false;\n    }\n    /**\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n     * filepath directly (without read directory).\n     */\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n    }\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n    }\n    return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n    const openingBraceIndex = pattern.indexOf('{');\n    if (openingBraceIndex === -1) {\n        return false;\n    }\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n    if (closingBraceIndex === -1) {\n        return false;\n    }\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n    return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n    return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern, { flipBackslashes: false });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n    return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n    const basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n    return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n    }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n    const patterns = micromatch.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });\n    /**\n     * Sort the patterns by length so that the same depth patterns are processed side by side.\n     * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`\n     */\n    patterns.sort((a, b) => a.length - b.length);\n    /**\n     * Micromatch can return an empty string in the case of patterns like `{a,}`.\n     */\n    return patterns.filter((pattern) => pattern !== '');\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\n    /**\n     * The scan method returns an empty array in some cases.\n     * See micromatch/picomatch#58 for more details.\n     */\n    if (parts.length === 0) {\n        parts = [pattern];\n    }\n    /**\n     * The scan method does not return an empty part for the pattern with a forward slash.\n     * This is another part of micromatch/picomatch#58.\n     */\n    if (parts[0].startsWith('/')) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift('');\n    }\n    return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map((pattern) => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n    return patternsRe.some((patternRe) => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n/**\n * This package only works with forward slashes as a path separator.\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\n */\nfunction removeDuplicateSlashes(pattern) {\n    return pattern.replace(DOUBLE_SLASH_RE, '/');\n}\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}