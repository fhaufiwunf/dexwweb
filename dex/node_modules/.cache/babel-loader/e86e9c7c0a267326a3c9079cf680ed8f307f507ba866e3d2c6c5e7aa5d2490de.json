{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearParseAndGenerateServicesCalls = exports.clearProgramCache = exports.parseWithNodeMaps = exports.parseAndGenerateServices = exports.parse = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst ast_converter_1 = require(\"./ast-converter\");\nconst convert_1 = require(\"./convert\");\nconst createDefaultProgram_1 = require(\"./create-program/createDefaultProgram\");\nconst createIsolatedProgram_1 = require(\"./create-program/createIsolatedProgram\");\nconst createProjectProgram_1 = require(\"./create-program/createProjectProgram\");\nconst createSourceFile_1 = require(\"./create-program/createSourceFile\");\nconst useProvidedPrograms_1 = require(\"./create-program/useProvidedPrograms\");\nconst createParseSettings_1 = require(\"./parseSettings/createParseSettings\");\nconst semantic_or_syntactic_errors_1 = require(\"./semantic-or-syntactic-errors\");\nconst log = (0, debug_1.default)('typescript-eslint:typescript-estree:parser');\n/**\n * Cache existing programs for the single run use-case.\n *\n * clearProgramCache() is only intended to be used in testing to ensure the parser is clean between tests.\n */\nconst existingPrograms = new Map();\nfunction clearProgramCache() {\n  existingPrograms.clear();\n}\nexports.clearProgramCache = clearProgramCache;\n/**\n * @param parseSettings Internal settings for parsing the file\n * @param shouldProvideParserServices True if the program should be attempted to be calculated from provided tsconfig files\n * @returns Returns a source file and program corresponding to the linted code\n */\nfunction getProgramAndAST(parseSettings, shouldProvideParserServices) {\n  return parseSettings.programs && (0, useProvidedPrograms_1.useProvidedPrograms)(parseSettings.programs, parseSettings) || shouldProvideParserServices && (0, createProjectProgram_1.createProjectProgram)(parseSettings) || shouldProvideParserServices && parseSettings.createDefaultProgram && (0, createDefaultProgram_1.createDefaultProgram)(parseSettings) || (0, createIsolatedProgram_1.createIsolatedProgram)(parseSettings);\n}\nfunction parse(code, options) {\n  const {\n    ast\n  } = parseWithNodeMapsInternal(code, options, false);\n  return ast;\n}\nexports.parse = parse;\nfunction parseWithNodeMapsInternal(code, options, shouldPreserveNodeMaps) {\n  /**\n   * Reset the parse configuration\n   */\n  const parseSettings = (0, createParseSettings_1.createParseSettings)(code, options);\n  /**\n   * Ensure users do not attempt to use parse() when they need parseAndGenerateServices()\n   */\n  if (options === null || options === void 0 ? void 0 : options.errorOnTypeScriptSyntacticAndSemanticIssues) {\n    throw new Error(`\"errorOnTypeScriptSyntacticAndSemanticIssues\" is only supported for parseAndGenerateServices()`);\n  }\n  /**\n   * Create a ts.SourceFile directly, no ts.Program is needed for a simple parse\n   */\n  const ast = (0, createSourceFile_1.createSourceFile)(parseSettings);\n  /**\n   * Convert the TypeScript AST to an ESTree-compatible one\n   */\n  const {\n    estree,\n    astMaps\n  } = (0, ast_converter_1.astConverter)(ast, parseSettings, shouldPreserveNodeMaps);\n  return {\n    ast: estree,\n    esTreeNodeToTSNodeMap: astMaps.esTreeNodeToTSNodeMap,\n    tsNodeToESTreeNodeMap: astMaps.tsNodeToESTreeNodeMap\n  };\n}\nfunction parseWithNodeMaps(code, options) {\n  return parseWithNodeMapsInternal(code, options, true);\n}\nexports.parseWithNodeMaps = parseWithNodeMaps;\nlet parseAndGenerateServicesCalls = {};\n// Privately exported utility intended for use in typescript-eslint unit tests only\nfunction clearParseAndGenerateServicesCalls() {\n  parseAndGenerateServicesCalls = {};\n}\nexports.clearParseAndGenerateServicesCalls = clearParseAndGenerateServicesCalls;\nfunction parseAndGenerateServices(code, options) {\n  var _a, _b;\n  /**\n   * Reset the parse configuration\n   */\n  const parseSettings = (0, createParseSettings_1.createParseSettings)(code, options);\n  if (options !== undefined) {\n    if (typeof options.errorOnTypeScriptSyntacticAndSemanticIssues === 'boolean' && options.errorOnTypeScriptSyntacticAndSemanticIssues) {\n      parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues = true;\n    }\n  }\n  /**\n   * If this is a single run in which the user has not provided any existing programs but there\n   * are programs which need to be created from the provided \"project\" option,\n   * create an Iterable which will lazily create the programs as needed by the iteration logic\n   */\n  if (parseSettings.singleRun && !parseSettings.programs && ((_a = parseSettings.projects) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n    parseSettings.programs = {\n      *[Symbol.iterator]() {\n        for (const configFile of parseSettings.projects) {\n          const existingProgram = existingPrograms.get(configFile);\n          if (existingProgram) {\n            yield existingProgram;\n          } else {\n            log('Detected single-run/CLI usage, creating Program once ahead of time for project: %s', configFile);\n            const newProgram = (0, useProvidedPrograms_1.createProgramFromConfigFile)(configFile);\n            existingPrograms.set(configFile, newProgram);\n            yield newProgram;\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Generate a full ts.Program or offer provided instances in order to be able to provide parser services, such as type-checking\n   */\n  const shouldProvideParserServices = parseSettings.programs != null || ((_b = parseSettings.projects) === null || _b === void 0 ? void 0 : _b.length) > 0;\n  /**\n   * If we are in singleRun mode but the parseAndGenerateServices() function has been called more than once for the current file,\n   * it must mean that we are in the middle of an ESLint automated fix cycle (in which parsing can be performed up to an additional\n   * 10 times in order to apply all possible fixes for the file).\n   *\n   * In this scenario we cannot rely upon the singleRun AOT compiled programs because the SourceFiles will not contain the source\n   * with the latest fixes applied. Therefore we fallback to creating the quickest possible isolated program from the updated source.\n   */\n  if (parseSettings.singleRun && options.filePath) {\n    parseAndGenerateServicesCalls[options.filePath] = (parseAndGenerateServicesCalls[options.filePath] || 0) + 1;\n  }\n  const {\n    ast,\n    program\n  } = parseSettings.singleRun && options.filePath && parseAndGenerateServicesCalls[options.filePath] > 1 ? (0, createIsolatedProgram_1.createIsolatedProgram)(parseSettings) : getProgramAndAST(parseSettings, shouldProvideParserServices);\n  /**\n   * Convert the TypeScript AST to an ESTree-compatible one, and optionally preserve\n   * mappings between converted and original AST nodes\n   */\n  const shouldPreserveNodeMaps = typeof parseSettings.preserveNodeMaps === 'boolean' ? parseSettings.preserveNodeMaps : true;\n  const {\n    estree,\n    astMaps\n  } = (0, ast_converter_1.astConverter)(ast, parseSettings, shouldPreserveNodeMaps);\n  /**\n   * Even if TypeScript parsed the source code ok, and we had no problems converting the AST,\n   * there may be other syntactic or semantic issues in the code that we can optionally report on.\n   */\n  if (program && parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues) {\n    const error = (0, semantic_or_syntactic_errors_1.getFirstSemanticOrSyntacticError)(program, ast);\n    if (error) {\n      throw (0, convert_1.convertError)(error);\n    }\n  }\n  /**\n   * Return the converted AST and additional parser services\n   */\n  return {\n    ast: estree,\n    services: {\n      hasFullTypeInformation: shouldProvideParserServices,\n      program,\n      esTreeNodeToTSNodeMap: astMaps.esTreeNodeToTSNodeMap,\n      tsNodeToESTreeNodeMap: astMaps.tsNodeToESTreeNodeMap\n    }\n  };\n}\nexports.parseAndGenerateServices = parseAndGenerateServices;","map":{"version":3,"mappings":"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","names":["log","existingPrograms","Map","clearProgramCache","clear","exports","getProgramAndAST","parseSettings","shouldProvideParserServices","programs","createDefaultProgram","parse","code","options","ast","parseWithNodeMapsInternal","shouldPreserveNodeMaps","errorOnTypeScriptSyntacticAndSemanticIssues","Error","estree","astMaps","esTreeNodeToTSNodeMap","tsNodeToESTreeNodeMap","parseWithNodeMaps","parseAndGenerateServicesCalls","clearParseAndGenerateServicesCalls","parseAndGenerateServices","undefined","singleRun","projects","length","Symbol","iterator","configFile","existingProgram","get","newProgram","set","filePath","program","preserveNodeMaps","error","services","hasFullTypeInformation"],"sources":["../src/parser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}